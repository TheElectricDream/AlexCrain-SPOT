var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"CollectPhaseSpaceDataJetson","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: ert_main.cpp\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"CollectPhaseSpaceDataJetson.h\"\r\n#include \"CollectPhaseSpaceDataJetson_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"MW_raspi_init.h\"\r\n#include \"MW_Pyserver_control.h\"\r\n#include \"linuxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n// Function prototype declaration\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\nsem_t stopSem;\r\nsem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(CollectPhaseSpaceDataJetson_M) == (NULL)) &&\r\n    !rtmGetStopRequested(CollectPhaseSpaceDataJetson_M);\r\n  while (runModel) {\r\n    sem_wait(&baserateTaskSem);\r\n    CollectPhaseSpaceDataJetson_step();\r\n\r\n    // Get model outputs here\r\n    stopRequested = !((rtmGetErrorStatus(CollectPhaseSpaceDataJetson_M) == (NULL))\r\n                      && !rtmGetStopRequested(CollectPhaseSpaceDataJetson_M));\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, \"stopping the model\");\r\n  runModel = 0;\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  MW_killPyserver();\r\n  mwRaspiTerminate();\r\n\r\n  // Terminate model\r\n  CollectPhaseSpaceDataJetson_terminate();\r\n  sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n  UNUSED(argc);\r\n  UNUSED(argv);\r\n  mwRaspiInit();\r\n  MW_launchPyserver();\r\n  rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, 0);\r\n\r\n  // Initialize model\r\n  CollectPhaseSpaceDataJetson_initialize();\r\n\r\n  // Call RTOS Initialization function\r\n  myRTOSInit(0.05, 0);\r\n\r\n  // Wait for stop semaphore\r\n  sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(sem_destroy(&timerTaskSem[i]), 0, \"sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"CollectPhaseSpaceDataJetson.cpp","type":"source","group":"model","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: CollectPhaseSpaceDataJetson.cpp\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#include \"CollectPhaseSpaceDataJetson.h\"\r\n#include <cstring>\r\n#include \"rtwtypes.h\"\r\n\r\n// Block signals (default storage)\r\nB_CollectPhaseSpaceDataJetson_T CollectPhaseSpaceDataJetson_B;\r\n\r\n// Block states (default storage)\r\nDW_CollectPhaseSpaceDataJetso_T CollectPhaseSpaceDataJetson_DW;\r\n\r\n// Real-time model\r\nRT_MODEL_CollectPhaseSpaceDat_T CollectPhaseSpaceDataJetson_M_ =\r\n  RT_MODEL_CollectPhaseSpaceDat_T();\r\nRT_MODEL_CollectPhaseSpaceDat_T *const CollectPhaseSpaceDataJetson_M =\r\n  &CollectPhaseSpaceDataJetson_M_;\r\n\r\n// Model step function\r\nvoid CollectPhaseSpaceDataJetson_step(void)\r\n{\r\n  real_T y10;\r\n  real_T y11;\r\n  real_T y12;\r\n  real_T y13;\r\n  real_T y14;\r\n  real_T y15;\r\n  char_T *sErr;\r\n\r\n  // MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n  if (CollectPhaseSpaceDataJetson_DW.obj.PS_SampleRate !=\r\n      CollectPhaseSpaceDataJetson_P.StreamPhaseSpacetoPlatform_PS_S) {\r\n    CollectPhaseSpaceDataJetson_DW.obj.PS_SampleRate =\r\n      CollectPhaseSpaceDataJetson_P.StreamPhaseSpacetoPlatform_PS_S;\r\n  }\r\n\r\n  //         %% Define output properties\r\n  CollectPhaseSpaceDataJetson_B.b_y1 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y2 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[3] = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y4 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y5 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[6] = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y7 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y8 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.y9 = 0.0;\r\n  y10 = 0.0;\r\n  y11 = 0.0;\r\n  y12 = 0.0;\r\n  y13 = 0.0;\r\n  y14 = 0.0;\r\n  y15 = 0.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[15] = 0.0;\r\n  stream_phasespace(&CollectPhaseSpaceDataJetson_B.b_y1,\r\n                    &CollectPhaseSpaceDataJetson_B.y2,\r\n                    &CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[3],\r\n                    &CollectPhaseSpaceDataJetson_B.y4,\r\n                    &CollectPhaseSpaceDataJetson_B.y5,\r\n                    &CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[6],\r\n                    &CollectPhaseSpaceDataJetson_B.y7,\r\n                    &CollectPhaseSpaceDataJetson_B.y8,\r\n                    &CollectPhaseSpaceDataJetson_B.y9, &y10, &y11, &y12, &y13,\r\n                    &y14, &y15,\r\n                    &CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[15]);\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[0] =\r\n    CollectPhaseSpaceDataJetson_B.y7 /\r\n    CollectPhaseSpaceDataJetson_DW.obj.PS_SampleRate;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[1] =\r\n    CollectPhaseSpaceDataJetson_B.b_y1 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[2] =\r\n    CollectPhaseSpaceDataJetson_B.y2 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[4] =\r\n    CollectPhaseSpaceDataJetson_B.y4 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[5] =\r\n    CollectPhaseSpaceDataJetson_B.y5 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[7] =\r\n    CollectPhaseSpaceDataJetson_B.y8 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[8] =\r\n    CollectPhaseSpaceDataJetson_B.y9 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[9] = y10 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[10] = y11 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[11] = y12 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[12] = y13 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[13] = y14 / 1000.0;\r\n  CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[14] = y15 / 1000.0;\r\n\r\n  // End of MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n  // RelationalOperator: '<S1>/Compare' incorporates:\r\n  //   Constant: '<S1>/Constant'\r\n  //   MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n  for (int32_T i = 0; i < 16; i++) {\r\n    CollectPhaseSpaceDataJetson_B.Compare[i] =\r\n      (CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[i] !=\r\n       CollectPhaseSpaceDataJetson_P.Constant_Value);\r\n  }\r\n\r\n  // End of RelationalOperator: '<S1>/Compare'\r\n\r\n  // Outputs for Enabled SubSystem: '<Root>/Enabled Subsystem1' incorporates:\r\n  //   EnablePort: '<S2>/Enable'\r\n\r\n  // RelationalOperator: '<S1>/Compare'\r\n  if (CollectPhaseSpaceDataJetson_B.Compare[0] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[1] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[2] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[3] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[4] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[5] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[6] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[7] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[8] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[9] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[10] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[11] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[12] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[13] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[14] ||\r\n      CollectPhaseSpaceDataJetson_B.Compare[15]) {\r\n    // SignalConversion generated from: '<S2>/In1' incorporates:\r\n    //   MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n    std::memcpy(&CollectPhaseSpaceDataJetson_B.In1[0],\r\n                &CollectPhaseSpaceDataJetson_B.StreamPhaseSpacetoPlatform[0],\r\n                sizeof(real_T) << 4U);\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Enabled Subsystem1'\r\n\r\n  // Update for S-Function (sdspToNetwork): '<Root>/UDP Send1' incorporates:\r\n  //   SignalConversion generated from: '<S2>/In1'\r\n\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n  LibUpdate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U],\r\n                    &CollectPhaseSpaceDataJetson_B.In1[0U], 16);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  // End of Update for S-Function (sdspToNetwork): '<Root>/UDP Send1'\r\n\r\n  // Update for S-Function (sdspToNetwork): '<Root>/UDP Send2' incorporates:\r\n  //   SignalConversion generated from: '<S2>/In1'\r\n\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n  LibUpdate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U],\r\n                    &CollectPhaseSpaceDataJetson_B.In1[0U], 16);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  // End of Update for S-Function (sdspToNetwork): '<Root>/UDP Send2'\r\n\r\n  // Update for S-Function (sdspToNetwork): '<Root>/UDP Send3' incorporates:\r\n  //   SignalConversion generated from: '<S2>/In1'\r\n\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n  LibUpdate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U],\r\n                    &CollectPhaseSpaceDataJetson_B.In1[0U], 16);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  // End of Update for S-Function (sdspToNetwork): '<Root>/UDP Send3'\r\n\r\n  // Update for S-Function (sdspToNetwork): '<Root>/UDP Send4' incorporates:\r\n  //   SignalConversion generated from: '<S2>/In1'\r\n\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n  LibUpdate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U],\r\n                    &CollectPhaseSpaceDataJetson_B.In1[0U], 16);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  // End of Update for S-Function (sdspToNetwork): '<Root>/UDP Send4'\r\n}\r\n\r\n// Model initialize function\r\nvoid CollectPhaseSpaceDataJetson_initialize(void)\r\n{\r\n  {\r\n    char_T *sErr;\r\n\r\n    // Start for S-Function (sdspToNetwork): '<Root>/UDP Send1'\r\n    sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n    CreateUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n    if (*sErr == 0) {\r\n      LibCreate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U],\r\n                        1, \"0.0.0.0\", -1, \"192.168.0.101\",\r\n                        CollectPhaseSpaceDataJetson_P.UDPSend1_Port, 8192, 8, 0);\r\n    }\r\n\r\n    if (*sErr == 0) {\r\n      LibStart(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n    }\r\n\r\n    if (*sErr != 0) {\r\n      DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n      if (*sErr != 0) {\r\n        rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n        rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n      }\r\n    }\r\n\r\n    // End of Start for S-Function (sdspToNetwork): '<Root>/UDP Send1'\r\n\r\n    // Start for S-Function (sdspToNetwork): '<Root>/UDP Send2'\r\n    sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n    CreateUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n    if (*sErr == 0) {\r\n      LibCreate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U],\r\n                        1, \"0.0.0.0\", -1, \"192.168.0.107\",\r\n                        CollectPhaseSpaceDataJetson_P.UDPSend2_Port, 8192, 8, 0);\r\n    }\r\n\r\n    if (*sErr == 0) {\r\n      LibStart(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n    }\r\n\r\n    if (*sErr != 0) {\r\n      DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n      if (*sErr != 0) {\r\n        rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n        rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n      }\r\n    }\r\n\r\n    // End of Start for S-Function (sdspToNetwork): '<Root>/UDP Send2'\r\n\r\n    // Start for S-Function (sdspToNetwork): '<Root>/UDP Send3'\r\n    sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n    CreateUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n    if (*sErr == 0) {\r\n      LibCreate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U],\r\n                        1, \"0.0.0.0\", -1, \"192.168.0.100\",\r\n                        CollectPhaseSpaceDataJetson_P.UDPSend3_Port, 8192, 8, 0);\r\n    }\r\n\r\n    if (*sErr == 0) {\r\n      LibStart(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n    }\r\n\r\n    if (*sErr != 0) {\r\n      DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n      if (*sErr != 0) {\r\n        rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n        rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n      }\r\n    }\r\n\r\n    // End of Start for S-Function (sdspToNetwork): '<Root>/UDP Send3'\r\n\r\n    // Start for S-Function (sdspToNetwork): '<Root>/UDP Send4'\r\n    sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n    CreateUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n    if (*sErr == 0) {\r\n      LibCreate_Network(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U],\r\n                        1, \"0.0.0.0\", -1, \"192.168.0.104\",\r\n                        CollectPhaseSpaceDataJetson_P.UDPSend4_remotePort, 8192,\r\n                        8, 0);\r\n    }\r\n\r\n    if (*sErr == 0) {\r\n      LibStart(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n    }\r\n\r\n    if (*sErr != 0) {\r\n      DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n      if (*sErr != 0) {\r\n        rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n        rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n      }\r\n    }\r\n\r\n    // End of Start for S-Function (sdspToNetwork): '<Root>/UDP Send4'\r\n\r\n    // SystemInitialize for Enabled SubSystem: '<Root>/Enabled Subsystem1'\r\n    for (int32_T i = 0; i < 16; i++) {\r\n      // SystemInitialize for SignalConversion generated from: '<S2>/In1' incorporates:\r\n      //   Outport: '<S2>/Out1'\r\n\r\n      CollectPhaseSpaceDataJetson_B.In1[i] =\r\n        CollectPhaseSpaceDataJetson_P.Out1_Y0;\r\n    }\r\n\r\n    // End of SystemInitialize for SubSystem: '<Root>/Enabled Subsystem1'\r\n\r\n    // Start for MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n    CollectPhaseSpaceDataJetson_DW.obj.matlabCodegenIsDeleted = true;\r\n\r\n    //  Constructor\r\n    CollectPhaseSpaceDataJetson_DW.obj.isInitialized = 0;\r\n\r\n    //  Support name-value pair arguments when constructing the object.\r\n    CollectPhaseSpaceDataJetson_DW.obj.matlabCodegenIsDeleted = false;\r\n    CollectPhaseSpaceDataJetson_DW.obj.PS_SampleRate =\r\n      CollectPhaseSpaceDataJetson_P.StreamPhaseSpacetoPlatform_PS_S;\r\n    CollectPhaseSpaceDataJetson_DW.obj.isSetupComplete = false;\r\n    CollectPhaseSpaceDataJetson_DW.obj.isInitialized = 1;\r\n\r\n    //         %% Define output properties\r\n    //  Call C-function implementing device initialization\r\n    initialize_phasespace(CollectPhaseSpaceDataJetson_DW.obj.PS_SampleRate);\r\n    CollectPhaseSpaceDataJetson_DW.obj.isSetupComplete = true;\r\n  }\r\n}\r\n\r\n// Model terminate function\r\nvoid CollectPhaseSpaceDataJetson_terminate(void)\r\n{\r\n  char_T *sErr;\r\n\r\n  // Terminate for MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n  if (!CollectPhaseSpaceDataJetson_DW.obj.matlabCodegenIsDeleted) {\r\n    CollectPhaseSpaceDataJetson_DW.obj.matlabCodegenIsDeleted = true;\r\n    if ((CollectPhaseSpaceDataJetson_DW.obj.isInitialized == 1) &&\r\n        CollectPhaseSpaceDataJetson_DW.obj.isSetupComplete) {\r\n      //  Call C-function implementing device termination\r\n      terminate_phasespace();\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n  // Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send1'\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n  LibTerminate(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  LibDestroy(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U], 1);\r\n  DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend1_NetworkLib[0U]);\r\n\r\n  // End of Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send1'\r\n\r\n  // Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send2'\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n  LibTerminate(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  LibDestroy(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U], 1);\r\n  DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend2_NetworkLib[0U]);\r\n\r\n  // End of Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send2'\r\n\r\n  // Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send3'\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n  LibTerminate(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  LibDestroy(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U], 1);\r\n  DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend3_NetworkLib[0U]);\r\n\r\n  // End of Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send3'\r\n\r\n  // Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send4'\r\n  sErr = GetErrorBuffer(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n  LibTerminate(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n  if (*sErr != 0) {\r\n    rtmSetErrorStatus(CollectPhaseSpaceDataJetson_M, sErr);\r\n    rtmSetStopRequested(CollectPhaseSpaceDataJetson_M, 1);\r\n  }\r\n\r\n  LibDestroy(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U], 1);\r\n  DestroyUDPInterface(&CollectPhaseSpaceDataJetson_DW.UDPSend4_NetworkLib[0U]);\r\n\r\n  // End of Terminate for S-Function (sdspToNetwork): '<Root>/UDP Send4'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"CollectPhaseSpaceDataJetson.h","type":"header","group":"model","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: CollectPhaseSpaceDataJetson.h\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_CollectPhaseSpaceDataJetson_h_\r\n#define RTW_HEADER_CollectPhaseSpaceDataJetson_h_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"owl.hpp\"\r\n#include \"phasespace_headers.h\"\r\n#include \"DAHostLib_Network.h\"\r\n#include \"CollectPhaseSpaceDataJetson_types.h\"\r\n#include <stddef.h>\r\n\r\n// Macros for accessing real-time model data structure\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n// Block signals (default storage)\r\nstruct B_CollectPhaseSpaceDataJetson_T {\r\n  real_T In1[16];                      // '<S2>/In1'\r\n  real_T StreamPhaseSpacetoPlatform[16];\r\n                                      // '<Root>/Stream PhaseSpace to Platform'\r\n  boolean_T Compare[16];               // '<S1>/Compare'\r\n  real_T b_y1;\r\n  real_T y2;\r\n  real_T y4;\r\n  real_T y5;\r\n  real_T y7;\r\n  real_T y8;\r\n  real_T y9;\r\n};\r\n\r\n// Block states (default storage) for system '<Root>'\r\nstruct DW_CollectPhaseSpaceDataJetso_T {\r\n  PhaseSpace_ALL_CollectPhaseSp_T obj;// '<Root>/Stream PhaseSpace to Platform'\r\n  real_T UDPSend1_NetworkLib[137];     // '<Root>/UDP Send1'\r\n  real_T UDPSend2_NetworkLib[137];     // '<Root>/UDP Send2'\r\n  real_T UDPSend3_NetworkLib[137];     // '<Root>/UDP Send3'\r\n  real_T UDPSend4_NetworkLib[137];     // '<Root>/UDP Send4'\r\n};\r\n\r\n// Parameters (default storage)\r\nstruct P_CollectPhaseSpaceDataJetson_T_ {\r\n  int32_T UDPSend4_remotePort;         // Mask Parameter: UDPSend4_remotePort\r\n                                          //  Referenced by: '<Root>/UDP Send4'\r\n\r\n  real_T Out1_Y0;                      // Computed Parameter: Out1_Y0\r\n                                          //  Referenced by: '<S2>/Out1'\r\n\r\n  real_T StreamPhaseSpacetoPlatform_PS_S;// Expression: 20\r\n                                            //  Referenced by: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n  real_T Constant_Value;               // Expression: 0\r\n                                          //  Referenced by: '<S1>/Constant'\r\n\r\n  int32_T UDPSend1_Port;               // Computed Parameter: UDPSend1_Port\r\n                                          //  Referenced by: '<Root>/UDP Send1'\r\n\r\n  int32_T UDPSend2_Port;               // Computed Parameter: UDPSend2_Port\r\n                                          //  Referenced by: '<Root>/UDP Send2'\r\n\r\n  int32_T UDPSend3_Port;               // Computed Parameter: UDPSend3_Port\r\n                                          //  Referenced by: '<Root>/UDP Send3'\r\n\r\n};\r\n\r\n// Real-time Model Data Structure\r\nstruct tag_RTM_CollectPhaseSpaceData_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  //\r\n  //  Timing:\r\n  //  The following substructure contains information regarding\r\n  //  the timing information for the model.\r\n\r\n  struct {\r\n    boolean_T stopRequestedFlag;\r\n  } Timing;\r\n};\r\n\r\n// Block parameters (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern P_CollectPhaseSpaceDataJetson_T CollectPhaseSpaceDataJetson_P;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n// Block signals (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern struct B_CollectPhaseSpaceDataJetson_T CollectPhaseSpaceDataJetson_B;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n// Block states (default storage)\r\nextern struct DW_CollectPhaseSpaceDataJetso_T CollectPhaseSpaceDataJetson_DW;\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  // Model entry point functions\r\n  extern void CollectPhaseSpaceDataJetson_initialize(void);\r\n  extern void CollectPhaseSpaceDataJetson_step(void);\r\n  extern void CollectPhaseSpaceDataJetson_terminate(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n// Real-time Model object\r\n#ifdef __cplusplus\r\n\r\nextern \"C\" {\r\n\r\n#endif\r\n\r\n  extern RT_MODEL_CollectPhaseSpaceDat_T *const CollectPhaseSpaceDataJetson_M;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n#endif\r\n\r\n//-\r\n//  These blocks were eliminated from the model due to optimizations:\r\n//\r\n//  Block '<Root>/Data Type Conversion' : Eliminate redundant data type conversion\r\n\r\n\r\n//-\r\n//  The generated code includes comments that allow you to trace directly\r\n//  back to the appropriate location in the model.  The basic format\r\n//  is <system>/block_name, where system is the system number (uniquely\r\n//  assigned by Simulink) and block_name is the name of the block.\r\n//\r\n//  Use the MATLAB hilite_system command to trace the generated code back\r\n//  to the model.  For example,\r\n//\r\n//  hilite_system('<S3>')    - opens system 3\r\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n//\r\n//  Here is the system hierarchy for this model\r\n//\r\n//  '<Root>' : 'CollectPhaseSpaceDataJetson'\r\n//  '<S1>'   : 'CollectPhaseSpaceDataJetson/Compare To Zero1'\r\n//  '<S2>'   : 'CollectPhaseSpaceDataJetson/Enabled Subsystem1'\r\n\r\n#endif                             // RTW_HEADER_CollectPhaseSpaceDataJetson_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"CollectPhaseSpaceDataJetson_private.h","type":"header","group":"model","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: CollectPhaseSpaceDataJetson_private.h\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_CollectPhaseSpaceDataJetson_private_h_\r\n#define RTW_HEADER_CollectPhaseSpaceDataJetson_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif                     // RTW_HEADER_CollectPhaseSpaceDataJetson_private_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"CollectPhaseSpaceDataJetson_types.h","type":"header","group":"model","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: CollectPhaseSpaceDataJetson_types.h\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_CollectPhaseSpaceDataJetson_types_h_\r\n#define RTW_HEADER_CollectPhaseSpaceDataJetson_types_h_\r\n#include \"rtwtypes.h\"\r\n\r\n// Model Code Variants\r\n#ifndef struct_PhaseSpace_ALL_CollectPhaseSp_T\r\n#define struct_PhaseSpace_ALL_CollectPhaseSp_T\r\n\r\nstruct PhaseSpace_ALL_CollectPhaseSp_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T PS_SampleRate;\r\n};\r\n\r\n#endif                                // struct_PhaseSpace_ALL_CollectPhaseSp_T\r\n\r\n// Parameters (default storage)\r\ntypedef struct P_CollectPhaseSpaceDataJetson_T_ P_CollectPhaseSpaceDataJetson_T;\r\n\r\n// Forward declaration for rtModel\r\ntypedef struct tag_RTM_CollectPhaseSpaceData_T RT_MODEL_CollectPhaseSpaceDat_T;\r\n\r\n#endif                       // RTW_HEADER_CollectPhaseSpaceDataJetson_types_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"CollectPhaseSpaceDataJetson_data.cpp","type":"source","group":"data","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: CollectPhaseSpaceDataJetson_data.cpp\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#include \"CollectPhaseSpaceDataJetson.h\"\r\n\r\n// Block parameters (default storage)\r\nP_CollectPhaseSpaceDataJetson_T CollectPhaseSpaceDataJetson_P = {\r\n  // Mask Parameter: UDPSend4_remotePort\r\n  //  Referenced by: '<Root>/UDP Send4'\r\n\r\n  25001,\r\n\r\n  // Computed Parameter: Out1_Y0\r\n  //  Referenced by: '<S2>/Out1'\r\n\r\n  0.0,\r\n\r\n  // Expression: 20\r\n  //  Referenced by: '<Root>/Stream PhaseSpace to Platform'\r\n\r\n  20.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S1>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: UDPSend1_Port\r\n  //  Referenced by: '<Root>/UDP Send1'\r\n\r\n  25000,\r\n\r\n  // Computed Parameter: UDPSend2_Port\r\n  //  Referenced by: '<Root>/UDP Send2'\r\n\r\n  25000,\r\n\r\n  // Computed Parameter: UDPSend3_Port\r\n  //  Referenced by: '<Root>/UDP Send3'\r\n\r\n  25000\r\n};\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtwtypes.h\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n// Logical type definitions\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n//=======================================================================*\r\n//  Target hardware information\r\n//    Device type: MATLAB Host\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32    long long:  64\r\n//                        native word size:  64\r\n//    Byte ordering: LittleEndian\r\n//    Signed integer division rounds to: Zero\r\n//    Shift right on a signed integer as arithmetic shift: on\r\n// =======================================================================\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n//===========================================================================*\r\n//  Complex number type definitions                                           *\r\n// ===========================================================================\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n//=======================================================================*\r\n//  Min and Max:                                                          *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n// =======================================================================\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n// Block D-Work pointer type\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 // RTWTYPES_H\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtmodel.h\r\n//\r\n// Code generated for Simulink model 'CollectPhaseSpaceDataJetson'.\r\n//\r\n// Model version                  : 5.2\r\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\r\n// C/C++ source code generated on : Sun Jul 17 13:19:08 2022\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Emulation hardware selection:\r\n//    Differs from embedded hardware (MATLAB Host)\r\n// Code generation objective: Execution efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"CollectPhaseSpaceDataJetson.h\"\r\n#endif                                 // RTW_HEADER_rtmodel_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"DAHostLib_Network.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2022a\\toolbox\\shared\\spc\\src_ml\\extern\\src","tag":"","groupDisplay":"Static files","code":"/**\n * @file DAHostLib_Network.c\n * Copyright 2009-2016 The MathWorks, Inc.\n */ \n\n#include \"DAHostLib_Network.h\"\n#include <string.h>\n#include <stdio.h>\n\n#if defined(_WIN32)\nconst char *libName_Network = \"networkdevice.dll\";\n#elif defined(__APPLE__)\nconst char *libName_Network = \"libmwnetworkdevice.dylib\";\n#else\nconst char *libName_Network = \"libmwnetworkdevice.so\";\n#endif\n\n#ifdef _USE_TARGET_UDP_\nvoid CreateTargetUDPInterface(void *hl);\nvoid DestroyTargetUDPInterface(void *hl);\n#endif\n\nvoid CreateUDPInterface(void *hl) \n{\n#ifndef _USE_TARGET_UDP_\n    CreateHostLibrary(libName_Network, hl);\n#else\n    CreateTargetUDPInterface(hl);\n#endif\n}\nvoid DestroyUDPInterface(void *hl) \n{\n#ifndef _USE_TARGET_UDP_\n    DestroyHostLibrary(hl);\n#else\n    DestroyTargetUDPInterface(hl);\n#endif\n}\n\n\nvoid LibCreate_Network(void *hl, int inOut, const char *localURL, int localPort, \n                       const char *remoteURL, int remotePort, int bufferSize, int bytesPerSample, int blockingTime)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    *hostLib->errorMessage  = '\\0';\n    (MAKE_FCN_PTR(pFnLibCreate_Network,hostLib->libCreate))(&hostLib->instance, hostLib->errorMessage, (NetworkInputOrOutput)inOut, \n                                                    localURL, localPort, remoteURL, remotePort, bufferSize, bytesPerSample, blockingTime);\n}\nvoid LibUpdate_Network(void *hl, const void *src, int nSamples)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibUpdate_Network,hostLib->libUpdate))(hostLib->instance, hostLib->errorMessage, src, nSamples);\n}\nvoid LibOutputs_Network(void *hl, void *src, int *nSamples)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibOutputs_Network,hostLib->libOutputs))(hostLib->instance, hostLib->errorMessage, src, nSamples);\n}\n"},{"name":"DAHostLib_rtw.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2022a\\toolbox\\shared\\spc\\src_ml\\extern\\src","tag":"","groupDisplay":"Static files","code":"/**\n * @file DAHostLib_rtw.c\n * @brief Helper for C clients of the HostLib library.\n * Copyright 2007-2017 The MathWorks, Inc.\n */ \n\n#include <string.h>\n#include <stdio.h>\n\n#include \"DAHostLib_rtw.h\"\n\n/* Open the library and initialize the function pointers */\nvoid CreateHostLibrary(const char *libName, void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    *hostLib->errorMessage = '\\0';\n    memset(hostLib, 0, sizeof(HostLibrary));\n#if defined(_WIN32)\n    hostLib->library = LoadLibrary(libName);\n    if(hostLib->library == NULL)\n        sprintf(hostLib->errorMessage, \"Could not open library: %s.\\nTo run the generated code outside the MATLAB environment, use the packNGo function.\\n\", libName);\n    else {\n        hostLib->libCreate    = GetProcAddress(hostLib->library, \"libCreate\");\n        hostLib->libStart     = GetProcAddress(hostLib->library, \"libStart\"); \n        hostLib->libReset     = GetProcAddress(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = GetProcAddress(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = GetProcAddress(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = GetProcAddress(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = GetProcAddress(hostLib->library, \"libDestroy\");\n    }\n#elif defined(_VXWORKS_)\n    hostLib->library = dlopen(libName, RTLD_NOW);\n    if(hostLib->library == NULL) {\n        sprintf(hostLib->errorMessage, \"Could not open library: %s\", libName);\n    }\n    else {\n        hostLib->libCreate    = dlsym(hostLib->library, \"libCreate\");\n        hostLib->libStart     = dlsym(hostLib->library, \"libStart\"); \n        hostLib->libReset     = dlsym(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = dlsym(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = dlsym(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = dlsym(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = dlsym(hostLib->library, \"libDestroy\");\n    }\n#else\n    hostLib->library = dlopen(libName, RTLD_NOW | RTLD_LOCAL);\n    if(hostLib->library == NULL) {\n        sprintf(hostLib->errorMessage, \"Could not open library: %s\", libName);\n    }\n    else {\n        hostLib->libCreate    = dlsym(hostLib->library, \"libCreate\");\n        hostLib->libStart     = dlsym(hostLib->library, \"libStart\"); \n        hostLib->libReset     = dlsym(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = dlsym(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = dlsym(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = dlsym(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = dlsym(hostLib->library, \"libDestroy\");\n    }\n#endif\n    if(!*hostLib->errorMessage && \n       (!hostLib->libCreate ||\n        !hostLib->libStart ||\n        !hostLib->libUpdate ||\n        !hostLib->libOutputs ||\n        !hostLib->libTerminate ||\n        !hostLib->libDestroy)\n        ) \n    {\n        sprintf(hostLib->errorMessage, \"Could not determine function entry points in %s\", libName);\n    }\n    if(*hostLib->errorMessage) {\n        if (hostLib->library) DestroyHostLibrary(hostLib);\n        fprintf(stderr,\"%s\",hostLib->errorMessage);\n    }\n}\n\n/* Close the library */\nvoid DestroyHostLibrary(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->library) {\n#if defined(_WIN32)\n        FreeLibrary(hostLib->library);\n#else\n        dlclose(hostLib->library);\n#endif\n        /* Clear the structure (except for any possible error message). */\n\t\tmemset(hostLib, 0, sizeof(HostLibrary) - MAX_ERR_MSG_LEN);\n    }\n}\n\nvoid LibStart(void *hl)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibStart,hostLib->libStart))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibReset(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance && hostLib->libReset)\n        (MAKE_FCN_PTR(pFnLibReset,hostLib->libReset))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibTerminate(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibTerminate,hostLib->libTerminate))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibDestroy(void *hl, int type)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n    {\n        (MAKE_FCN_PTR(pFnLibDestroy,hostLib->libDestroy))(hostLib->instance, hostLib->errorMessage, type);\n        hostLib->instance = NULL;\n    }\n}\n\nint LibError(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    return hostLib->errorMessage[0] != '\\0';\n}\nvoid PrintError(char *message)\n{\n    /* Print, and then reset, the error message */\n    printf(\"Error: %s\\n\", message);\n    message[0] = '\\0';\n}\nvoid PrintWarning(char *message)\n{\n    /* Print, and then reset, the warning message */\n    printf(\"Warning: %s\\n\", message);\n    message[0] = '\\0';\n}\nchar * GetErrorBuffer(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    return hostLib->errorMessage;\n}\nvoid * GetNullPointer(void) \n{\n    return NULL;\n}\n"},{"name":"MW_Pyserver_control.c","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2022a\\toolbox\\realtime\\targets\\raspi\\src\\periphs","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019-2021 The MathWorks, Inc. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <error.h>\n#include <signal.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdint.h>\n#include \"MW_Pyserver_control.h\"\n#if !defined(_MATLABIO_) && defined(MW_DASHBLOCK_INUSE)\n    #include \"MW_target_hardware_resources.h\"\n#endif\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n#define AT __FILE__ \":\" TOSTRING(__LINE__)\n\nstatic char exePath[65534 + 1];\n\n#if defined(MW_WEBSOC_INUSE) \n    static char pyserverLoc[65534 + 1];\n#elif defined(MW_DASHBLOCK_INUSE)\n    static char dashboardpyserverLoc[4095 + 1];\n    static char dashboardhttpserverLoc[4095 + 1];\n    static char dashboardlaunchscriptLoc[4095 + 1];\n#endif\n\nvoid MW_getDefines() {\n    char pwd[65535];\n    char* p;\n\n    readlink(\"/proc/self/exe\", pwd, 65535);\n\n    strcpy(exePath, pwd);\n    if ((p = strrchr(exePath, '/')))\n        *(p + 1) = '\\0';\n    printf(\"Path = %s\\n\", exePath);\n#ifdef _MATLABIO_\n    sprintf(pyserverLoc, \"%sMW_pyserver.py\", exePath);\n#else\n    #if defined(MW_WEBSOC_INUSE) \n        sprintf(pyserverLoc, \"%s%s_ert_rtw/MW_pyserver.py\", exePath, TOSTRING(MODEL));\n    #elif defined(MW_DASHBLOCK_INUSE)\n        sprintf(dashboardpyserverLoc, \"%s%s_ert_rtw/MW_dashboard_pyserver.py\", exePath, TOSTRING(MODEL));\n        sprintf(dashboardhttpserverLoc, \"%s%s_ert_rtw/MW_dashboard_httpserver.py\", exePath, TOSTRING(MODEL));\n        sprintf(dashboardlaunchscriptLoc, \"%s%s_ert_rtw/launchdashboardwebpage.sh\", exePath, TOSTRING(MODEL));\n    #endif\n#endif\n    #if defined(MW_WEBSOC_INUSE) \n        printf(\"PyserverLocation = %s\\n\", pyserverLoc);\n    #elif defined(MW_DASHBLOCK_INUSE)\n        printf(\"DashboardPyserverLocation = %s\\n\", dashboardpyserverLoc);\n        printf(\"DashboardhttpserverLocation = %s\\n\", dashboardhttpserverLoc);\n        printf(\"dashboardlaunchscriptLocation = %s\\n\", dashboardlaunchscriptLoc);\n    #endif\n}\n\n\nvoid MW_killPyserver() {\n#if defined(MW_WEBSOC_INUSE)\n    printf(\" Attempt to kill web socket processes\\n \");\n    fflush(stdout);\n    char buff[200];\n    sprintf(buff, \"sudo pkill -f %s\", pyserverLoc);\n    system(buff);\n    printf(\"Killed web socket server \\n\");\n#elif defined(MW_DASHBLOCK_INUSE)\n    printf(\" Attempt to kill dashboard processes\\n \");\n    fflush(stdout);\n    char buff[500];\n    sprintf(buff, \"sudo kill -15 $(ps aux | grep  '.*/usr/lib/chromium-browser/chromium-browser.*--incognito --app=.*http://%s:%d.*/toolbox/simulink/webblocks/webmanager-js/index.html.*%s.*%d' | grep -v grep | awk '{ print $2 }')\",TOSTRING(MW_DASHBOARDPARAMETERS_IPADDRESS), MW_DASHBOARDPARAMETERS_HTTPPORT, TOSTRING(MW_DASHBOARDPARAMETERS_IPADDRESS), MW_DASHBOARDPARAMETERS_WEBSOCKETPORT);\n    system(buff);\n    sprintf(buff, \"sudo pkill -f %s\", dashboardpyserverLoc);\n    system(buff);\n    sprintf(buff, \"sudo pkill -f %s\", dashboardhttpserverLoc);\n    system(buff);\n    sprintf(buff, \"sudo rm -rf /tmp/%s*.ipc\", TOSTRING(MODEL));\n    system(buff);\n#endif\n#if defined(MW_WEBSOC_INUSE) || defined(MW_DASHBLOCK_INUSE)\n    sprintf(buff, \"sudo rm -rf /tmp/pylog.txt\");\n    system(buff);\n#endif\n}\n\nvoid MW_launchPyserver() {\n    char cmd[255];\n    char jsonFileLoc[1024];\n    MW_getDefines();\n#ifdef _MATLABIO_\n    sprintf(jsonFileLoc, \"/tmp/MW_websocInfo.json\");\n    sprintf(cmd, \"sudo %s %s >/tmp/mw_websoc_sl_io.log &\", pyserverLoc, jsonFileLoc);\n    printf(\"Launching websocket server at %s\\n\", cmd);\n    MW_execmd(cmd);\n#else\n    #if defined(MW_WEBSOC_INUSE)\n        sprintf(jsonFileLoc, \"%s%s_ert_rtw/MW_websocInfo.json\", exePath, TOSTRING(MODEL));\n        sprintf(cmd, \"sudo %s %s >/dev/null &\", pyserverLoc, jsonFileLoc);\n        printf(\"Launching websocket server at %s\\n\", cmd);\n        MW_execmd(cmd);\n    #elif defined(MW_DASHBLOCK_INUSE) \n        sprintf(jsonFileLoc, \"%s%s_ert_rtw/MW_dashblockInfo.json\", exePath, TOSTRING(MODEL));\n        sprintf(cmd,\"chmod +x %s\", dashboardpyserverLoc);\n        MW_execmd(cmd);\n        sprintf(cmd, \"sudo %s %s >%s%s_ert_rtw/%s.log &\", dashboardpyserverLoc, jsonFileLoc, exePath,TOSTRING(MODEL),TOSTRING(MODEL));\n        printf(\"Launching dashboard websocket server at %s\\n\", cmd);\n        MW_execmd(cmd);\n        sprintf(cmd,\"chmod +x %s\", dashboardhttpserverLoc);\n        MW_execmd(cmd);\n        sprintf(cmd, \"sudo %s %s%s_ert_rtw/ %s %d >%s%s_ert_rtw/%s.log &\", dashboardhttpserverLoc, exePath, TOSTRING(MODEL), TOSTRING(MW_DASHBOARDPARAMETERS_IPADDRESS), MW_DASHBOARDPARAMETERS_HTTPPORT, exePath,TOSTRING(MODEL),TOSTRING(MODEL));\n        printf(\"Launching dashboard http server at %s\\n\", cmd);\n        MW_execmd(cmd);    \n        sprintf(cmd,\"chmod +x %s\", dashboardlaunchscriptLoc);\n        MW_execmd(cmd);\n        sprintf(cmd, \"sudo -u %s %s >%s%s_ert_rtw/%s.log &\", TOSTRING(MW_BOARDPARAMETERS_USERNAME), dashboardlaunchscriptLoc, exePath, TOSTRING(MODEL), TOSTRING(MODEL));\n        printf(\"Launching webpage at %s\\n\", cmd);\n        MW_execmd(cmd); \n    #endif\n#endif\n}\n\n\nvoid MW_execmd(char* buff) {\n    int ret = 0, bufferLoc = 0;\n    FILE *fp, *fd;\n    char buffer[65535];\n    size_t readLength = 0;\n    uint32_t outSize = 65535;\n\n    fd = fopen(\"/tmp/pylog.txt\", \"w\");\n    fprintf(fd, \"%s\\n\", buff);\n    fclose(fd);\n\n    fp = popen(buff, \"r\");\n    if (fp == NULL) {\n        printf(\"Error in executing the cmd \\n\");\n        return;\n    }\n\n    /*Read the cmd output if any */\n    while (fgets((buffer + bufferLoc), (outSize - bufferLoc), fp) != NULL) {\n        readLength = strlen(buffer + bufferLoc);\n\n        if ((bufferLoc + readLength) < outSize) {\n            // Advance the pointer to new location\n            bufferLoc += readLength;\n        } else {\n            // cmd output exceeds outSize chars\n            break;\n        }\n    }\n\n    printf(\"cmd buffer - %s\\n\", buffer);\n    pclose(fp);\n    return;\n}\n\n/* LocalWords:  PAth pyserver pgrep awk xargs sudo dev tmp pylog\n */\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           40\r\n#define MW_BASERATE_PERIOD             0.05\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern sem_t stopSem;\r\nextern sem_t baserateTaskSem;\r\nextern sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_raspi_init.c","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2022a\\toolbox\\realtime\\targets\\raspi\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2021 The MathWorks, Inc. */\n#include <stdio.h>\n#include <stdlib.h>\n#include \"MW_raspi_init.h\"\n\n#if defined(MW_RASPI_EXTINTERRUPT) || defined(MW_RASPI_ROTARYENCODER) || defined(MW_PWMBLOCK)\n#include <pigpio.h>\n#endif\n\n// Overrun detection function\nvoid mwRaspiInit(void)\n{\n#if defined(MW_RASPI_EXTINTERRUPT) || defined(MW_RASPI_ROTARYENCODER) || defined(MW_PWMBLOCK)\n    int retStatusInt;\n#endif\n\n    printf(\"**** Starting the application ****\\n\");\n    fflush(stdout);\n#ifdef MW_MATLABTARGET  \n    /*Signal Handling */\n    signal(SIGTERM, main_terminate);     /* kill */\n    signal(SIGHUP, main_terminate);      /* kill -HUP */\n    signal(SIGINT, main_terminate);      /* Interrupt from keyboard */\n    signal(SIGQUIT, main_terminate);     /* Quit from keyboard */\n#endif\n\n#if defined(MW_RASPI_EXTINTERRUPT) || defined(MW_RASPI_ROTARYENCODER) || defined(MW_PWMBLOCK)\n    // Start gpio library\n    system(\"sudo killall pigpiod\");\n    system(\"sudo rm /var/run/pigpio.pid\");\n    gpioCfgClock(5U, 1U, 0U);  // Best external interrupt turn around time\n    retStatusInt = gpioInitialise();\n    if(retStatusInt < 0){\n        fprintf(stderr,\"ERR_PIGPIO_INIT\\n\");\n        exit(-1);\n    }\n#endif\n}\n\nint mwRaspiTerminate(void)\n{\n#ifdef MW_MATLABTARGET\n    printf(\"**** Stopping the application ****\\n\");\n    fflush(stdout);\n    exit(1);\n#endif\n\n#if defined(MW_RASPI_EXTINTERRUPT) || defined(MW_RASPI_ROTARYENCODER) || defined(MW_PWMBLOCK)\n    // Stop gpio library\n    gpioTerminate();\n#endif\n    return(1);\n}\n\n// Overrun detection function\nvoid reportOverrun(int taskId)\n{\n#ifdef MW_RASPI_DETECTOVERRUN\n    printf(\"Overrun detected: The sample time for the rate %d is too short.\\n\", taskId);\n    fflush(stdout);\n#endif\n}\n\n/* LocalWords:  HUP MATLABTARGET\n */\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_raspi_init.h\"\n#include \"MW_Pyserver_control.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Raspberry Pi\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.raspi.getDeviceAddress\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONTCPIP_RUNINBACKGROUND 0\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS codertarget.raspi.getDeviceAddress\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_TCPIP_RUNINBACKGROUND 0\n#define MW_EXTMODE_CONFIGURATION XCP on TCP/IP\n#define MW_EXTMODE_SIGNALBUFFERSIZE 1000000.000000\n#define MW_EXTMODE_TARGETPOLLINGTIMEMODE 0\n#define MW_EXTMODE_TARGETPOLLINGTIME 2\n#define MW_RTOS Linux\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_DETECTTASKOVERRUNS 0.000000\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_BOARDPARAMETERS_DEVICEADDRESS 192.168.0.106\n#define MW_BOARDPARAMETERS_USERNAME pi\n#define MW_BOARDPARAMETERS_PASSWORD raspberry\n#define MW_BOARDPARAMETERS_BUILDDIR /home/pi/ExperimentSoftware/\n#define MW_BOARDPARAMETERS_DEVICENAME \n#define MW_BOARDPARAMETERS_ONLINEBUILDDIR /home/pi/ExperimentSoftware/\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_RUNTIME_RUNONBOOT 0\n#define MW_SPI_SPI0CE0BUSSPEED 6\n#define MW_SPI_SPI0CE1BUSSPEED 6\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 12\n#define MW_CAN_ALLOWALLFILTER 1\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0 0\n#define MW_CAN_ACCEPTANCEFILTER0 255\n#define MW_CAN_ACCEPTANCEFILTER1 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1 0\n#define MW_CAN_ACCEPTANCEFILTER2 255\n#define MW_CAN_ACCEPTANCEFILTER3 255\n#define MW_CAN_ACCEPTANCEFILTER4 255\n#define MW_CAN_ACCEPTANCEFILTER5 255\n#define MW_CAN_INVERSEFILTER0 0\n#define MW_CAN_INVERSEFILTER1 0\n#define MW_CAN_BUFFER2IDTYPE 1\n#define MW_CAN_ACCEPTANCEMASK2 0\n#define MW_CAN_INVERSEFILTER2 0\n#define MW_CAN_BUFFER3IDTYPE 1\n#define MW_CAN_ACCEPTANCEMASK3 0\n#define MW_CAN_INVERSEFILTER3 0\n#define MW_MQTT_BROKERADDRESS mqtt.thingspeak.com\n#define MW_MQTT_USERNAME \n#define MW_MQTT_PASSWORD \n#define MW_MQTT_CLIENTID \n#define MW_DATAVERSION 2016.02\n#define MW_SIMULINKIO_TRANSPORTLAYERTYPE 0\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN codertarget.raspi.ioclient.getModelTransportInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN codertarget.raspi.ioclient.deployServer\n#define MW_SIMULINKIO_TRANSPORTLAYERTYPEONLINE 0\n#define MW_IOBLOCKSMODE deployed\n#define MW_BUILDTIME_ENABLEPARALLELBUILD 1\n#define MW_MODBUS_MODBUS_COMMS 0\n#define MW_MODBUS_MODBUS_MODE 0\n#define MW_MODBUS_MODBUS_SERVERREMOTEPORT 502\n#define MW_MODBUS_MODBUS_SERVERLOCALPORT 502\n#define MW_MODBUS_MODBUS_CONFIGCOIL 49\n#define MW_MODBUS_MODBUS_COILADDR 0\n#define MW_MODBUS_MODBUS_COILNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUT 49\n#define MW_MODBUS_MODBUS_INPUTADDR 0\n#define MW_MODBUS_MODBUS_INPUTNUM 1\n#define MW_MODBUS_MODBUS_CONFIGHOLDINGREG 49\n#define MW_MODBUS_MODBUS_HOLDINGREGADDR 0\n#define MW_MODBUS_MODBUS_HOLDINGREGNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUTREG 49\n#define MW_MODBUS_MODBUS_INPUTREGADDR 0\n#define MW_MODBUS_MODBUS_INPUTREGNUM 1\n#define MW_MODBUS_MODBUS_MASTERTIMEOUT 100\n#define MW_DASHBOARDPARAMETERS_ENABLEDEPLOYMENT 0\n#define MW_DASHBOARDPARAMETERS_IPADDRESSTYPE 0\n#define MW_DASHBOARDPARAMETERS_IPADDRESS 192.168.0.106\n#define MW_DASHBOARDPARAMETERS_WEBSOCKETPORT 8000\n#define MW_DASHBOARDPARAMETERS_HTTPPORT 8888\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"filters.cpp","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\Custom_Library\\PhaseSpase_Cameras\\PHASESPACE\\src","tag":"","groupDisplay":"Other files","code":"/***\r\nCopyright (c) PhaseSpace, Inc 2016\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL PHASESPACE, INC\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n***/\r\n\r\n// filters.cc -*- C++ -*-\r\n// OWL C++ API v2.0\r\n\r\n#include <iostream>\r\n\r\n#include <assert.h>\r\n\r\n#include \"libowl.h\"\r\n#include \"vector.h\"\r\n\r\nusing namespace OWL;\r\n\r\n////\r\n\r\ntemplate <> inline Vector::Vector(const Marker &m) : x(m.x), y(m.y), z(m.z) {}\r\n\r\ninline void set_marker(const Vector &v, float cond, Marker &m)\r\n{ m.x = v.x; m.y = v.y; m.z = v.z; m.cond = cond; }\r\n\r\ninline size_t find_valid_markers(const Frames &frames, uint32_t id, std::vector<size_t> &indexes)\r\n{\r\n  indexes.clear();\r\n  for(size_t f = 0; f < frames.size(); f++)\r\n    if(frames[f].markers[id].cond > 0 && (frames[f].markers[id].flags & 0x10) == 0)\r\n      indexes.push_back(f);\r\n  return indexes.size();\r\n}\r\n\r\n//// FilterGroup ////\r\n\r\nFilterGroup::FilterGroup(uint32_t id, const std::string &name, uint32_t period, bool enable) :\r\n  enabled(enable), period(period), name(name), in(id, period*2), out(id, period*2)\r\n{ }\r\n\r\nvoid FilterGroup::clear()\r\n{\r\n  enabled = false;\r\n  period = 0;\r\n  while(!empty())\r\n    {\r\n      delete back();\r\n      pop_back();\r\n    }\r\n}\r\n\r\nvoid FilterGroup::setPeriod(uint32_t n)\r\n{\r\n  period = n;\r\n  in.capacity = out.capacity = 2 * n;\r\n  while(in.pop());\r\n  while(out.pop());\r\n}\r\n\r\nvoid FilterGroup::push(const EventPrivate &frame)\r\n{\r\n  if(!enabled || in.capacity <= 0 || !in.push(frame)) return;\r\n\r\n  for(Markers::iterator i = in.back().markers.begin(); i != in.back().markers.end(); i++)\r\n    if(i->flags & 0x10) i->cond = -1;\r\n\r\n  out.push_back(in.back());\r\n\r\n  apply();\r\n}\r\n\r\nbool FilterGroup::merge(const EventPrivate &frame)\r\n{\r\n  if(!enabled || out.capacity <= 0) return false;\r\n  return out.merge(frame);\r\n}\r\n\r\nbool FilterGroup::pop(EventPrivate &frame)\r\n{\r\n  bool ret = out.get(frame, period);\r\n  while(in.pop());\r\n  while(out.pop());\r\n  return ret;\r\n}\r\n\r\nvoid FilterGroup::apply()\r\n{\r\n  if(in.empty() || out.empty()) return;\r\n\r\n  size_t size = in.back().markers.size();\r\n\r\n  // idiot check\r\n  assert(out.size() == in.size());\r\n  for(Frames::iterator i = in.begin(); i != in.end(); i++) assert(i->markers.size() == size);\r\n  for(Frames::iterator i = out.begin(); i != out.end(); i++) assert(i->markers.size() == size);\r\n\r\n  Frames *in = &this->in, *out = &this->out, tmp;\r\n\r\n  for(size_t id = 0; id < size; id++)\r\n    for(iterator i = begin(); i != end(); i++)\r\n      {\r\n        if(i != begin()) { tmp = *out; in = &tmp; }\r\n        if(Filter *f = *i) f->apply(*in, *out, id, period);\r\n        else erase(i--);\r\n      }\r\n}\r\n\r\n//// Filters ////\r\n\r\nFilters::Filters(bool shared) : shared(shared), enabled(false)\r\n{\r\n}\r\n\r\nFilters::Filters(const Filters &f) : base(f), shared(f.shared), enabled(f.enabled)\r\n{\r\n}\r\n\r\nFilters::~Filters()\r\n{\r\n  if(!shared) clear();\r\n}\r\n\r\nvoid Filters::clear()\r\n{\r\n  while(!empty())\r\n    {\r\n      delete back();\r\n      pop_back();\r\n    }\r\n}\r\n\r\nFilterGroup* Filters::find(const std::string &name)\r\n{\r\n  for(iterator i = begin(); i != end(); i++)\r\n    {\r\n      if(FilterGroup *g = *i) { if(g->name == name) return g; }\r\n      else erase(i--);\r\n    }\r\n  return 0;\r\n}\r\n\r\nvoid Filters::push(const EventPrivate &frame)\r\n{\r\n  for(iterator i = begin(); i != end(); i++)\r\n    {\r\n      if(FilterGroup *g = *i) g->push(frame);\r\n      else erase(i--);\r\n    }\r\n}\r\n\r\nbool Filters::merge(const EventPrivate &frame)\r\n{\r\n  bool ret = false;\r\n  for(iterator i = begin(); i != end(); i++)\r\n    {\r\n      if(FilterGroup *g = *i) ret |= g->merge(frame);\r\n      else erase(i--);\r\n    }\r\n  return ret;\r\n}\r\n\r\n//// Filter ////\r\n\r\nFilter::Filter(const std::string &type) : type(type) { }\r\n\r\nFilter::~Filter() { }\r\n\r\nbool Filter::set(const strings &o)\r\n{ return false; }\r\n\r\nvoid Filter::apply(const Frames &in, Frames &out, size_t id, uint32_t period)\r\n{ }\r\n\r\n////\r\n\r\nnamespace OWL {\r\n\r\n  /*\r\n  class FILTER : public Filter {\r\n  public:\r\n\r\n    FILTER() : Filter(\"FILTER\") { }\r\n\r\n    bool set(const strings &o) { return false; }\r\n\r\n    void apply(const Frames &in, Frames &out, size_t id, uint32_t period) { }\r\n  };\r\n  */\r\n\r\n  //// NoOpFilter ////\r\n\r\n  class NoOpFilter : public Filter {\r\n  public:\r\n\r\n    NoOpFilter() : Filter(\"noop\") { }\r\n  };\r\n\r\n  //// LERP ////\r\n\r\n  class LERPFilter : public Filter {\r\n  public:\r\n\r\n    LERPFilter() : Filter(\"lerp\") { }\r\n\r\n    bool set(const strings &o) { return false; }\r\n\r\n    void apply(const Frames &in, Frames &out, size_t id, uint32_t period)\r\n    {\r\n      std::vector<size_t> valid;\r\n      if(find_valid_markers(out, id, valid) < 2) return;\r\n\r\n      for(size_t i = 0; i+1 < valid.size(); i++)\r\n        fill(out, id, valid[i], valid[i+1]);\r\n    }\r\n\r\n    // lerp\r\n    void fill(Frames &out, size_t id, size_t t0, size_t t1)\r\n    {\r\n      // dv = (v1 - v0) / (t1 - t0), o = dv * t + v0\r\n      size_t dt = t1 - t0;\r\n      const Vector &v0 = out[t0].markers[id], v1 = out[t1].markers[id];\r\n      const Vector dv = (v1 - v0) / dt;\r\n\r\n      for(size_t t = 1; t < dt && t0+t < out.size(); t++)\r\n        if(out[t0+t].markers[id].cond < 0)\r\n          {\r\n            const Vector o = dv * t + v0;\r\n            set_marker(o, 1, out[t0+t].markers[id]);\r\n          }\r\n    }\r\n\r\n  };\r\n\r\n  //// SplineFilter ////\r\n\r\n  // p=4, n=4*3+1=12+1 (minimal)\r\n  // 0 x x x 1 x x x 2 x x x 3\r\n  //         |-------|\r\n\r\n  // first: X 0 1 2, last: 0 1 2 X\r\n\r\n  // cubic hermite spline, finite difference slopes\r\n\r\n  class SplineFilter : public Filter {\r\n  public:\r\n\r\n    int order;\r\n\r\n    SplineFilter() : Filter(\"spline\"), order(3) { }\r\n\r\n    bool set(const strings &o)\r\n    {\r\n      if(o.size() != 2) return false;\r\n      if(o[0] == \"order\") order = strtoi(o[1]);\r\n      else return false;\r\n\r\n      this->options[o[0]] = o[1];\r\n\r\n      return true;\r\n    }\r\n\r\n    void apply(const Frames &in, Frames &out, size_t id, uint32_t period)\r\n    {\r\n      std::vector<size_t> valid;\r\n      if(find_valid_markers(out, id, valid) < 3) return;\r\n\r\n      if(valid.size() >= 4)\r\n        for(size_t i = 0; i+3 < valid.size(); i++)\r\n          spline(out, id, valid[i], valid[i+1], valid[i+2], valid[i+3]);\r\n      else if(valid.size() == 3)\r\n        {\r\n          if(valid[0] != 0 && valid[2] == (uint32_t)in.capacity) first(out, id, valid[0], valid[1], valid[2]);\r\n          else if(valid[0] == 0 && valid[2] != (uint32_t)in.capacity) last(out, id, valid[0], valid[1], valid[2]);\r\n        }\r\n      else if(valid.size() == 2)\r\n        lerp(out, id, valid[0], valid[1]);\r\n    }\r\n\r\n    void spline(Frames &out, size_t id, size_t i0, size_t i1, size_t i2, size_t i3)\r\n    {\r\n      // hermite spline t=[0,1], i1-i2\r\n      // mk = finite_difference(pk-1, pk, pk+1) * (tk+1 - tk)\r\n      // o = p1 * F0(t) + m1 * F1(t) * size + p2 * F2(t) + m2 * F3(t) * size, t=[0,1]\r\n      real size = i2 - i1, step = 1.0 / size;\r\n      const Vector &p0 = out[i0].markers[id], &p1 = out[i1].markers[id], &p2 = out[i2].markers[id], &p3 = out[i3].markers[id];\r\n      const Vector m1 = finite_difference(p0, p1, p2, i0, i1, i2) * size;\r\n      const Vector m2 = finite_difference(p1, p2, p3, i1, i2, i3) * size;\r\n\r\n      real t = step;\r\n      for(size_t i = i1+1; i < i2; i++, t+=step)\r\n        if(out[i].markers[id].cond < 0)\r\n          {\r\n            const Vector o = p1 * F0(t) + m1 * F1(t) + p2 * F2(t) + m2 * F3(t);\r\n            set_marker(o, 1, out[i].markers[id]);\r\n          }\r\n    }\r\n\r\n    void first(Frames &out, size_t id, size_t i0, size_t i1, size_t i2)\r\n    {\r\n      // hermite spline t=[0,1], i0-i1\r\n      // mk = finite_difference(pk-1, pk, pk+1) * (tk+1 - tk)\r\n      // o = p1 * F0(t) + m1 * F1(t) * size + p2 * F2(t) + m2 * F3(t) * size, t=[0,1]\r\n      real size = i1 - i0, step = 1.0 / size;\r\n      const Vector &p0 = out[i0].markers[id], &p1 = out[i1].markers[id], &p2 = out[i2].markers[id];\r\n      const Vector &m0 = (p1 - p0); // same as slope(p0, p1, i0, i1) * size;\r\n      const Vector &m1 = finite_difference(p0, p1, p2, i0, i1, i2) * size;\r\n\r\n      real t = step;\r\n      for(size_t i = i0+1; i < i1; i++, t+=step)\r\n        if(out[i].markers[id].cond < 0)\r\n          {\r\n            const Vector o = p0 * F0(t) + m0 * F1(t) + p1 * F2(t) + m1 * F3(t);\r\n            set_marker(o, 1, out[i].markers[id]);\r\n          }\r\n    }\r\n\r\n    void last(Frames &out, size_t id, size_t i0, size_t i1, size_t i2)\r\n    {\r\n      // hermite spline t=[0,1], i1-i2\r\n      // mk = finite_difference(pk-1, pk, pk+1) * (tk+1 - tk)\r\n      // o = p1 * F0(t) + m1 * F1(t) * size + p2 * F2(t) + m2 * F3(t) * size, t=[0,1]\r\n      real size = i2 - i1, step = 1.0 / size;\r\n      const Vector &p0 = out[i0].markers[id], &p1 = out[i1].markers[id], &p2 = out[i2].markers[id];\r\n      const Vector m1 = finite_difference(p0, p1, p2, i0, i1, i2) * size;\r\n      const Vector m2 = (p2 - p1); // same as slope(p1, p2, i1, i2) * size;\r\n\r\n      real t = step;\r\n      for(size_t i = i1+1; i < i2; i++, t+=step)\r\n        if(out[i].markers[i].cond < 0)\r\n          {\r\n            const Vector o = p1 * F0(t) + m1 * F1(t) + p2 * F2(t) + m2 * F3(t);\r\n            set_marker(o, 1, out[i].markers[id]);\r\n          }\r\n    }\r\n\r\n    void lerp(Frames &out, size_t id, size_t i0, size_t i1)\r\n    {\r\n      // lerp t=[0,1]\r\n      // m = (p1 - p0) / (t1 - t0) * (t1 - t0), o = m * t + v0\r\n      real size = i1 - i0, step = 1.0 / size;\r\n      const Vector &p0 = out[i0].markers[id], &p1 = out[i1].markers[id];\r\n      const Vector m = (p1 - p0); // same as slope(p0, p1, i0, i1) * size;\r\n\r\n      real t = step;\r\n      for(size_t i = i0+1; i < i1; i++, t+=step)\r\n        if(out[i].markers[id].cond < 0)\r\n          {\r\n            const Vector o = m * t + p0;\r\n            set_marker(o, 1, out[i].markers[id]);\r\n          }\r\n    }\r\n\r\n    static const Vector slope(const Vector &p0, const Vector &p1, size_t t0, size_t t1)\r\n    {\r\n      // first_mk = (pk+1 - pk) / (tk+1 - tk), last_mk = (pk - pk-1) / (tk - tk-1)\r\n      // first_m0 = (p1 - p0) / (t1 - t0), last_m1 = (p1 - p0) / (t1 - t0)\r\n      // m = (p1 - p0) / (t1 - t0)\r\n      return (p1 - p0) / (t1 - t0);\r\n    }\r\n\r\n    static const Vector finite_difference(const Vector &p0, const Vector &p1, const Vector &p2, size_t t0, size_t t1, size_t t2)\r\n    {\r\n      // mk = 0.5 * (pk+1 - pk) / (tk+1 - tk) + 0.5 * (pk - pk-1) / (tk - tk-1)\r\n      // m1 = 0.5 * (p2 - p1) / (t2 - t1) + 0.5 * (p1 - p0) / (t1 - t0)\r\n      return 0.5 * (p2 - p1) / (t2 - t1) + 0.5 * (p1 - p0) / (t1 - t0);\r\n    }\r\n\r\n    static const Vector cardinal(const Vector &p0, const Vector &p1, const Vector &p2, size_t t0, size_t t1, size_t t2)\r\n    {\r\n      // mk = (pk+1 - pk-1) / (tk+1 - tk-1)\r\n      // m1 = (p2 - p0) / (t2 - t0)\r\n      return (p2 - p0) / (t2 - t0);\r\n    }\r\n\r\n    // basis functions\r\n    static real F0(real t) { return 2*t*t*t - 3*t*t + 1; }\r\n    static real F1(real t) { return t*t*t - 2*t*t + t; }\r\n    static real F2(real t) { return -2*t*t*t + 3*t*t; }\r\n    static real F3(real t) { return t*t*t - t*t; }\r\n\r\n  };\r\n\r\n  //// AverageFilter ////\r\n\r\n  class AverageFilter : public Filter {\r\n  public:\r\n\r\n    AverageFilter() : Filter(\"average\") { }\r\n\r\n    bool set(const strings &o) { return false; }\r\n\r\n    void apply(const Frames &in, Frames &out, size_t id, uint32_t period)\r\n    {\r\n      if(period == 0 || period*2+1 >= in.size() || period*2+1 >= out.size()) return;\r\n      size_t start = in.size() - period*2-1, now = in.size() - period-1;\r\n\r\n      Vector a;\r\n      size_t n = 0;\r\n      for(size_t i = start; i < in.size(); i++)\r\n        if(in[i].markers[id].cond > 0)\r\n          {\r\n            a += Vector(in[i].markers[id]);\r\n            n++;\r\n          }\r\n      if(n == 0) return;\r\n\r\n      set_marker(a / n, 1, out[now].markers[id]);\r\n    }\r\n  };\r\n\r\n  //// create_filter() ////\r\n\r\n  Filter* create_filter(const strings &s)\r\n  {\r\n    if(s.empty()) return 0;\r\n    if(s[0] == \"noop\") return new NoOpFilter();\r\n    if(s[0] == \"lerp\") return new LERPFilter();\r\n    if(s[0] == \"spline\") return new SplineFilter();\r\n    if(s[0] == \"average\") return new AverageFilter();\r\n\r\n    return 0;\r\n  }\r\n\r\n} // namespace OWL\r\n\r\n////\r\n"},{"name":"libowl.cpp","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\Custom_Library\\PhaseSpase_Cameras\\PHASESPACE\\src","tag":"","groupDisplay":"Other files","code":"/***\r\nCopyright (c) PhaseSpace, Inc 2016\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL PHASESPACE, INC\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n***/\r\n\r\n// libowl.cc -*- C++ -*-\r\n// OWL C++ API v2.0\r\n// OWL::Context implementation\r\n\r\n#include <iostream>\r\n\r\n#include <string.h>\r\n\r\n#ifndef WIN32\r\n#include <sys/time.h>\r\n#else\r\n#include <windows.h>\r\n#include <algorithm>\r\n\r\n#ifndef _MSC_VER\r\n#include \"ntdef.h\"\r\n#endif\r\n\r\n#endif\r\n\r\n#include \"libowl.h\"\r\n#include \"protocol.h\"\r\n\r\n/*\r\n  open(name:port, \"timeout=t\")\r\n    wait(t)\r\n    return !names.empty\r\n\r\n  initialize(\"timeout=t slave=0|1 local=0|1\")\r\n    wait(t)\r\n    return slave>=0\r\n*/\r\n\r\nusing namespace std;\r\nusing namespace OWL;\r\n\r\n#define DATA_LOCKER() MutexLocker l(data?&data->mutex:0)\r\n#define CLEAR_ERROR() if(data) data->error.clear()\r\n#define SET_ERROR(e,r) { if(data) data->error = (e); return r; }\r\n#define OPEN_ERROR(e, r) \\\r\n  { data->properties.set(\"opened\", int(0)); data->error = (e); return r; }\r\n#define INITIALIZE_ERROR(e, r) \\\r\n  { data->properties.erase(\"initializing\"); data->properties.set(\"initialized\", int(0)); data->error = (e); return r; }\r\n#define DONE_ERROR(e, r) \\\r\n  { data->properties.erase(\"flushing\"); data->error = (e); return r; }\r\n\r\n/*\r\n  errors:\r\n  null context is handled by lastError() / owlLastError()\r\n  const functions can't set/clear errors\r\n*/\r\n\r\n//// utils ////\r\n\r\n#ifdef WIN32\r\ninline time_t timer() // usec\r\n{\r\n  LARGE_INTEGER f, t; QueryPerformanceFrequency(&f); QueryPerformanceCounter(&t);\r\n  return t.QuadPart * 1000000 / f.QuadPart;\r\n}\r\n#else // WIN32\r\ninline time_t timer() // usec\r\n{\r\n  timeval tv; gettimeofday(&tv, 0);\r\n  return tv.tv_sec * 1000000 + tv.tv_usec;\r\n}\r\n#endif\r\n\r\nconst Event* find_error(const Events &events)\r\n{\r\n  for(Events::const_iterator e = events.begin(); e != events.end(); e++)\r\n    if(e->type_id() == Type::ERROR && (strcmp(e->name(), \"error\") == 0 || strcmp(e->name(), \"fatal\") == 0))\r\n      return &*e;\r\n  return 0;\r\n}\r\n\r\n//// Context ////\r\n\r\nContext::Context() : data(0)\r\n{ }\r\n\r\nContext::~Context()\r\n{\r\n  close();\r\n  if(data)\r\n    {\r\n      data->mutex.lock();\r\n      CLEAR_ERROR();\r\n      // move data->mutex into this function\r\n      Mutex m; m.swap(data->mutex);\r\n      delete data;\r\n      data = 0;\r\n      m.unlock();\r\n    }\r\n}\r\n\r\nContext::Context(const Context &ctr)\r\n{ }\r\n\r\n// initialization //\r\n\r\nint Context::open(const std::string &name, const std::string &open_options)\r\n{\r\n  if(!data) data = new ContextData(Device::create(), \"libowl\");\r\n  MutexLocker l(&data->mutex);\r\n  CLEAR_ERROR();\r\n  if(data->property<int>(\"opened\") == 1) return 1;\r\n\r\n  stringmap m(open_options);\r\n  long timeout = get(m, \"timeout\", long(5000000)), t0 = timer(), left = 0;\r\n\r\n  // debug internal events\r\n  if(data->internal == 0) data->internal = get(m, \"internal\", int(0));\r\n\r\n  if(!data->isOpen())\r\n    {\r\n      data->clear();\r\n\r\n      data->properties.set(\"name\", name);\r\n\r\n      int ret = data->open(name, open_options);\r\n      if(ret < 0) OPEN_ERROR(data->error, ret);\r\n      if(ret == 0 && timeout > 0) OPEN_ERROR(\"error: Connection timed out\", -1);\r\n      if(ret == 0) return 0;\r\n    }\r\n\r\n  // wait for \"opened\" == 1\r\n  while(left >= 0)\r\n    {\r\n      int ret = data->recv(left);\r\n      if(ret < 0) OPEN_ERROR(data->error, ret);\r\n      if(data->property<int>(\"opened\") == 1) break;\r\n      if(const Event *e = find_error(data->events)) OPEN_ERROR(e->str(), -1);\r\n      if(timeout == 0 && data->dev->events.empty()) break;\r\n      left = timeout ? timeout - (timer() - t0) : 0;\r\n    }\r\n\r\n  if(data->property<int>(\"opened\") == 0)\r\n    {\r\n      if(timeout > 0) OPEN_ERROR(\"error: Connection timed out\", -1);\r\n      return 0;\r\n    }\r\n\r\n  // finish\r\n\r\n  ostring out;\r\n  out << \"protocol=\" << int(OWL_PROTOCOL_VERSION);\r\n#ifdef LIBOWL_REV\r\n  out << \" libowl=5.1.\" << LIBOWL_REV;\r\n#endif // LIBOWL_REV\r\n  if(data->send(\"internal\", out) <= 0) OPEN_ERROR(data->error, -1);\r\n\r\n  return 1;\r\n}\r\n\r\nbool Context::close()\r\n{\r\n  if(!data) return false;\r\n  done();\r\n  MutexLocker l(&data->mutex);\r\n  CLEAR_ERROR();\r\n  return data->close();\r\n}\r\n\r\nbool Context::isOpen() const\r\n{ DATA_LOCKER(); return data ? data->isOpen() > 0 && data->property<int>(\"opened\") == 1 : false; }\r\n\r\nint Context::initialize(const std::string &init_options)\r\n{\r\n  if(!data) return -1;\r\n  if(!isOpen()) SET_ERROR(\"error: Closed context\", -1);\r\n  MutexLocker l(&data->mutex);\r\n  CLEAR_ERROR();\r\n\r\n  stringmap m(init_options);\r\n  long timeout = get(m, \"timeout\", long(5000000)), t0 = timer(), left = 0;\r\n\r\n  if(data->property<int>(\"initialized\") == 1)\r\n    {\r\n      if(data->property<int>(\"flushing\") == 1) { data->error = \"error: busy\"; return 0; }\r\n      if(data->property<int>(\"initializing\") == 1) goto finish;\r\n\r\n      // re-initialize\r\n      data->properties.set(\"initialized\", int(0));\r\n    }\r\n\r\n  // debug internal events\r\n  if(data->internal == 0) data->internal = get(m, \"internal\", int(0));\r\n\r\n  if(data->property<int>(\"initializing\") == 0)\r\n    {\r\n      string name = data->properties(\"name\");\r\n      string profiles = data->properties(\"profiles\");\r\n      string defaultprofile = data->properties(\"defaultprofile\");\r\n      string profiles_json = data->properties(\"profiles.json\");\r\n\r\n      data->clear();\r\n\r\n      data->properties.set(\"opened\", int(1));\r\n      data->properties.set(\"initializing\", int(1));\r\n      data->properties.set(\"name\", name);\r\n      data->properties.set(\"profiles\", profiles);\r\n      data->properties.set(\"defaultprofile\", defaultprofile);\r\n      data->properties.set(\"profiles.json\", profiles_json);\r\n      data->properties.set(\"local\", get(m, \"local\", 0)); // handle \"local\"\r\n\r\n      string o = string(\"event.raw=1 event.markers=1 event.rigids=1\") + (init_options.empty()?\"\":\" \") + init_options;\r\n      data->enable(o);\r\n      if(data->send(\"initialize\", o) <= 0) INITIALIZE_ERROR(data->error, -1);\r\n    }\r\n\r\n  // wait for \"initialized\" == 1\r\n  while(left >= 0)\r\n    {\r\n      int ret = data->recv(left);\r\n      if(ret < 0) INITIALIZE_ERROR(data->error, ret);\r\n      if(data->property<int>(\"initialized\") == 1) break;\r\n      if(const Event *e = find_error(data->events)) INITIALIZE_ERROR(e->str(), -1);\r\n      if(timeout == 0 && data->dev->events.empty()) break;\r\n      left = timeout ? timeout - (timer() - t0) : 0;\r\n    }\r\n\r\n  if(data->property<int>(\"initialized\") == 0)\r\n    {\r\n      if(timeout > 0) INITIALIZE_ERROR(\"error: Connection timed out\", -1);\r\n      return 0;\r\n    }\r\n\r\n finish:\r\n\r\n  data->properties.erase(\"initializing\");\r\n\r\n  return 1;\r\n}\r\n\r\nint Context::done(const std::string &done_options)\r\n{\r\n  if(!data) return -1;\r\n  if(!isOpen()) SET_ERROR(\"error: Closed context\", -1);\r\n  MutexLocker l(&data->mutex);\r\n  CLEAR_ERROR();\r\n\r\n  stringmap m(done_options);\r\n  long timeout = get(m, \"timeout\", long(1000000)), t0 = timer(), left = 0;\r\n  string keepalive = get(m, \"keepalive\", false) ? \"keepalive=1\" : \"\";\r\n  if(data->property<int>(\"initialized\") == 0)\r\n    {\r\n      if(data->property<int>(\"initializing\") == 1) { data->error = \"error: busy\"; return 0; }\r\n      if(data->property<int>(\"flushing\") == 1) goto finish;\r\n      return 1;\r\n    }\r\n\r\n  if(data->property<int>(\"flushing\") == 0)\r\n    {\r\n      data->properties.set(\"flushing\", int(1));\r\n\r\n      if(data->send(\"done\", keepalive) <= 0) DONE_ERROR(data->error, -1);\r\n    }\r\n\r\n  // wait for \"initialized\" == 0\r\n  while(left >= 0)\r\n    {\r\n      int ret = data->recv(left);\r\n      if(ret < 0) DONE_ERROR(data->error, -1);\r\n      if(data->property<int>(\"initialized\") == 0) break;\r\n      if(const Event *e = find_error(data->events)) DONE_ERROR(e->str(), -1);\r\n      if(timeout == 0 && data->dev->events.empty()) break;\r\n      left = timeout ? timeout - (timer() - t0) : 0;\r\n    }\r\n\r\n  if(data->property<int>(\"initialized\") == 1)\r\n    {\r\n      if(timeout > 0) DONE_ERROR(\"error: timed out\", -1);\r\n      return 0;\r\n    }\r\n\r\n finish:\r\n\r\n  data->properties.erase(\"flushing\");\r\n\r\n  return 1;\r\n}\r\n\r\nint Context::streaming() const\r\n{ DATA_LOCKER(); return data ? data->property<int>(\"streaming\") : 0; }\r\n\r\nbool Context::streaming(int enable)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"streaming\", vector<int>(1, enable)) > 0;\r\n}\r\n\r\nfloat Context::frequency() const\r\n{ DATA_LOCKER(); return data ? data->property<float>(\"frequency\") : -1; }\r\n\r\nbool Context::frequency(float freq)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"frequency\", vector<float>(1, freq)) > 0;\r\n}\r\n\r\nconst int* Context::timeBase() const\r\n{ return data ? (const int*)data->properties(\"timebase\") : 0; }\r\n\r\nbool Context::timeBase(int num, int den)\r\n{\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  int r[2] = {num, den};\r\n  data->properties.set(\"timebase\", r, r+2);\r\n  // for local=0\r\n  return data->send(\"timebase\", vector<int>(r, r+2));\r\n}\r\n\r\nfloat Context::scale() const\r\n{ DATA_LOCKER(); return data ? data->property<float>(\"scale\") : -1; }\r\n\r\nbool Context::scale(float scale)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  if(data->property<int>(\"local\") == 1)\r\n    {\r\n      data->properties.set(\"scale\", scale);\r\n      Cameras c;\r\n      if(data->properties.get(\"systemcameras\", c))\r\n        {\r\n          EventPrivate e(Type::CAMERA, data->names[\"cameras\"], 0, data->dev->time, c);\r\n          data->new_event(e);\r\n        }\r\n    }\r\n  // for local=0\r\n  return data->send(Type::FLOAT, data->names[\"scale\"], 0, (const char*)&scale, sizeof(float)) > 0;\r\n}\r\n\r\nconst float* Context::pose() const\r\n{ DATA_LOCKER(); return data ? data->property<const float*>(\"pose\") : 0; }\r\n\r\nbool Context::pose(const float *pose)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  if(data->property<int>(\"local\") == 1)\r\n    {\r\n      data->properties.set(\"pose\", pose, pose+7);\r\n      Cameras c;\r\n      if(data->properties.get(\"systemcameras\", c))\r\n        {\r\n          EventPrivate e(Type::CAMERA, data->names[\"cameras\"], 0, data->dev->time, c);\r\n          data->new_event(e);\r\n        }\r\n    }\r\n  // for local=0\r\n  return data->send(Type::FLOAT, data->names[\"pose\"], 0, (const char*)pose, 7*sizeof(float)) > 0;\r\n}\r\n\r\nstd::string Context::option(const std::string &option) const\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return string();\r\n  stringmap::const_iterator i = data->options.find(option);\r\n  return i != data->options.end() ? i->second : string();\r\n}\r\n\r\nbool Context::option(const std::string &option, const std::string &value)\r\n{\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return options(option + \"=\" + value);\r\n}\r\n\r\nstd::string Context::options() const\r\n{ DATA_LOCKER(); return data ? data->properties(\"options\") : string(); }\r\n\r\nbool Context::options(const std::string &options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  data->enable(options);\r\n  return data->send(\"options\", options) > 0;\r\n}\r\n\r\nstd::string Context::lastError() const\r\n{ DATA_LOCKER(); return data ? data->error : string(\"error: Invalid context\"); }\r\n\r\n// markers //\r\n\r\nbool Context::markerName(uint32_t marker_id, const std::string &marker_name)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"markername\", ostring() << \"mid=\" << marker_id << \" name=\" << marker_name) > 0;\r\n}\r\n\r\nbool Context::markerOptions(uint32_t marker_id, const string &marker_options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"markeroptions\", ostring() << \"mid=\" << marker_id << \" \" << marker_options) > 0;\r\n}\r\n\r\nconst MarkerInfo Context::markerInfo(uint32_t marker_id) const\r\n{ DATA_LOCKER(); return data ? data->markers[marker_id] : MarkerInfo(); }\r\n\r\n// trackers //\r\n\r\nbool Context::createTracker(uint32_t tracker_id, const std::string &tracker_type,\r\n                            const std::string &tracker_name, const std::string &tracker_options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  ostring out;\r\n  out << \"id=\" << tracker_id << \" type=\" << tracker_type\r\n      << \" name=\" << (!tracker_name.empty() ? tracker_name : to_string(tracker_id));\r\n  if(!tracker_options.empty()) out << \" \" << tracker_options;\r\n  return data->send(\"createtracker\", out) > 0;\r\n}\r\n\r\nbool Context::createTrackers(const TrackerInfo *first, const TrackerInfo *last)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data || !first || !last || first == last) return false;\r\n  CLEAR_ERROR();\r\n  ostring out;\r\n  for(const TrackerInfo *i = first; i != last; i++)\r\n    {\r\n      out << (i==first?\"\":\" \") << \"id=\" << i->id\r\n\t  << \" type=\" << i->type\r\n\t  << \" name=\" << (!i->name.empty() ? i->name : to_string(i->id));\r\n      if(!i->marker_ids.empty()) out << \" mid=\" << i->marker_ids;\r\n      if(!i->options.empty()) out << \" \" << i->options;\r\n    }\r\n  return data->send(\"createtracker\", out) > 0;\r\n}\r\n\r\nbool Context::destroyTracker(uint32_t tracker_id)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"destroytracker\", ostring() << \"id=\" << tracker_id) > 0;\r\n}\r\n\r\nbool Context::destroyTrackers(const uint32_t *first, const uint32_t *last)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data || !first || !last || first == last) return false;\r\n  CLEAR_ERROR();\r\n  ostring out; out << \"id=\";\r\n  for(const uint32_t *i = first; i != last; i++)\r\n    out << (i==first?\"\":\",\") << *i;\r\n  return data->send(\"destroytracker\", out) > 0;\r\n}\r\n\r\nbool Context::assignMarker(uint32_t tracker_id, uint32_t marker_id,\r\n                            const std::string &marker_name, const std::string &marker_options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  ostring out;\r\n  out << \"tid=\" << tracker_id << \" mid=\" << marker_id\r\n      << \" name=\" << (!marker_name.empty() ? marker_name : to_string(marker_id));\r\n  if(!marker_options.empty()) out << \" \" << marker_options;\r\n  return data->send(\"assignmarker\", out) > 0;\r\n}\r\n\r\nbool Context::assignMarkers(const MarkerInfo *first, const MarkerInfo *last)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data || !first || !last || first == last) return false;\r\n  CLEAR_ERROR();\r\n  ostring out;\r\n  for(const MarkerInfo *i = first; i != last; i++)\r\n    {\r\n      out << (i==first?\"\":\" \") << \"tid=\" << i->tracker_id << \" mid=\" << i->id\r\n\t  << \" name=\" << (!i->name.empty() ? i->name : to_string(i->id));\r\n      if(!i->options.empty()) out << \" \" << i->options;\r\n    }\r\n  return data->send(\"assignmarker\", out) > 0;\r\n}\r\n\r\nbool Context::trackerName(uint32_t tracker_id, const std::string &tracker_name)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"trackername\", ostring() << \"id=\" << tracker_id << \" name=\" << tracker_name) > 0;\r\n}\r\n\r\nbool Context::trackerOptions(uint32_t tracker_id, const std::string &tracker_options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n  return data->send(\"trackeroptions\", ostring() << \"id=\" << tracker_id << \" \" << tracker_options) > 0;\r\n}\r\n\r\nconst TrackerInfo Context::trackerInfo(uint32_t tracker_id) const\r\n{ DATA_LOCKER(); return data ? data->trackers[tracker_id] : TrackerInfo(); }\r\n\r\n// filter //\r\n\r\nbool Context::filter(uint32_t period, const std::string &name, const std::string &filter_options)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return false;\r\n  CLEAR_ERROR();\r\n\r\n  if(data->property<int>(\"local\") == 1)\r\n    {\r\n      FilterInfo fi(period, name, filter_options);\r\n      return data->filter(&fi, &fi+1, true);\r\n    }\r\n\r\n  ostringstream out;\r\n  out << \"filter=\" << name << \" period=\" << period;\r\n  if(!filter_options.empty()) out << \" \" << filter_options;\r\n\r\n  return data->send(\"filter\", out.str());\r\n}\r\n\r\nbool Context::filters(const FilterInfo *first, const FilterInfo *last)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data || !first || !last || first == last) return false;\r\n  CLEAR_ERROR();\r\n\r\n  if(data->property<int>(\"local\") == 1) return data->filter(first, last, true);\r\n\r\n  ostring out;\r\n  for(const FilterInfo *i = first; i != last; i++)\r\n    {\r\n      out << (i==first?\"\":\" \") << \"filter=\" << i->name << \" period=\" << i->period;\r\n      if(!i->options.empty()) out << \" \" << i->options;\r\n    }\r\n\r\n  return data->send(\"filter\", out);\r\n}\r\n\r\nconst FilterInfo Context::filterInfo(const std::string &name) const\r\n{ DATA_LOCKER(); return data ? data->filterInfo(name) : FilterInfo(); }\r\n\r\n// devices //\r\n\r\nconst DeviceInfo Context::deviceInfo(uint64_t hw_id) const\r\n{ DATA_LOCKER(); return data ? data->devices[hw_id] : DeviceInfo(); }\r\n\r\n// events //\r\n\r\nconst Event* Context::peekEvent(long timeout)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return 0;\r\n  CLEAR_ERROR();\r\n  return data->peekEvent(timeout);\r\n}\r\n\r\nconst Event* Context::nextEvent(long timeout)\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return 0;\r\n  CLEAR_ERROR();\r\n  return data->nextEvent(timeout);\r\n}\r\n\r\n// property //\r\n\r\nconst Variant Context::property(const std::string &name) const\r\n{\r\n  DATA_LOCKER();\r\n  if(!data) return Variant();\r\n  CLEAR_ERROR();\r\n  if(name == \"*\")\r\n    {\r\n      string out;\r\n      for(Properties::const_iterator i = data->properties.begin(); i != data->properties.end(); i++)\r\n        if(!i->first.empty())\r\n          {\r\n            if(i != data->properties.begin()) out.append(\",\");\r\n            out.append(i->first);\r\n          }\r\n      return VariantPrivate(Type::BYTE, 0, out.data(), out.data()+out.size(), data->types[Type::BYTE].name);\r\n    }\r\n  return data->properties(name);\r\n}\r\n\r\n#undef CLEAR_ERROR\r\n#undef SET_ERROR\r\n\r\n////\r\n\r\n#if !defined(_MSC_VER) || (_MSC_VER > 1600)\r\n\r\n#include \"owl.h\"\r\n\r\nconst OWLEvent* copy_event(const OWL::Event *e, OWLEvent &event)\r\n{\r\n  event.type_id = e->type_id();\r\n  event.id = e->id();\r\n  event.flags = e->flags();\r\n  event.time = e->time();\r\n  event.type_name = e->type_name();\r\n  event.name = e->name();\r\n  event.data = e->begin();\r\n  event.data_end = e->end();\r\n  return &event;\r\n}\r\n\r\nconst OWLEvent* copy_frame(const OWL::Event *f, OWLEvent &frame, std::vector<OWLEvent> &events)\r\n{\r\n  events.clear();\r\n  for(const OWL::Event *e = f->begin(); e != f->end(); e++)\r\n    {\r\n      events.push_back(OWLEvent());\r\n      copy_event(e, events.back());\r\n    }\r\n  frame.type_id = f->type_id();\r\n  frame.id = f->id();\r\n  frame.flags = f->flags();\r\n  frame.time = f->time();\r\n  frame.type_name = f->type_name();\r\n  frame.name = f->name();\r\n  frame.data = events.data();\r\n  frame.data_end = events.data()+events.size();\r\n  return &frame;\r\n}\r\n\r\ntemplate <typename T>\r\nint get(const Variant &v, int type_id, T *value, uint32_t count)\r\n{\r\n  if(!value || v.type_id() != type_id || !(const T*)v.begin() || !(const T*)v.end()) return -1;\r\n  if(count == 0) return 0;\r\n  uint32_t size = min<long>((const T*)v.end() - (const T*)v.begin(), (long)count);\r\n  memcpy(value, (const void*)v, size * sizeof(T));\r\n  return size;\r\n}\r\n\r\ntemplate <typename T>\r\nint get(const OWLEvent *e, int type_id, T *value, uint32_t count)\r\n{\r\n  if(!e || !e->data || !e->data_end || !type_id || !value || e->type_id != type_id) return -1;\r\n  if(count == 0) return 0;\r\n  uint32_t size = min<long>((const T*)e->data_end - (const T*)e->data, (long)count);\r\n  memcpy(value, (const void*)e->data, size * sizeof(T));\r\n  return size;\r\n}\r\n\r\nstruct OWLContext : public Context {\r\n\r\n  OWLEvent event;\r\n\r\n  vector<OWLEvent> frameEvents;\r\n\r\n  OWLContext() : Context()\r\n  { }\r\n\r\n  ~OWLContext()\r\n  {\r\n    close();\r\n  }\r\n\r\n  const ContextData* data() const { return Context::data; }\r\n};\r\n\r\nOWLContext* owlCreateContext()\r\n{ return new OWLContext(); }\r\n\r\nbool owlReleaseContext(struct OWLContext **ctx)\r\n{\r\n  if(!ctx) return false;\r\n  delete *ctx;\r\n  *ctx = 0;\r\n  return true;\r\n}\r\n\r\nint owlOpen(struct OWLContext *ctx, const char *name, const char *open_options)\r\n{ return ctx && name ? ctx->open(name, open_options?open_options:\"\") : -1; }\r\n\r\nbool owlClose(struct OWLContext *ctx)\r\n{ return ctx ? ctx->close() : false; }\r\n\r\nbool owlIsOpen(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->isOpen() : false; }\r\n\r\nint owlInitialize(struct OWLContext *ctx, const char *init_options)\r\n{ return ctx ? ctx->initialize(init_options?init_options:\"\") : -1; }\r\n\r\nint owlDone(struct OWLContext *ctx, const char *done_options)\r\n{ return ctx ? ctx->done(done_options?done_options:\"\") : -1; }\r\n\r\nint owlStreaming(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->streaming() : 0; }\r\n\r\nbool owlSetStreaming(struct OWLContext *ctx, int enable)\r\n{ return ctx ? ctx->streaming(enable) : false; }\r\n\r\nfloat owlFrequency(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->frequency() : -1; }\r\n\r\nbool owlSetFrequency(struct OWLContext *ctx, float frequency)\r\n{ return ctx ? ctx->frequency(frequency) : false; }\r\n\r\nconst int* owlTineBase(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->timeBase() : 0; }\r\n\r\nbool owlSetTimeBase(struct OWLContext *ctx, int num, int den)\r\n{ return ctx ? ctx->timeBase(num, den) : false; }\r\n\r\nfloat owlScale(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->scale() : -1; }\r\n\r\nbool owlSetScale(struct OWLContext *ctx, float scale)\r\n{ return ctx ? ctx->scale(scale) : false; }\r\n\r\nconst float* owlPose(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->pose() : 0; }\r\n\r\nbool owlSetPose(struct OWLContext *ctx, const float *pose)\r\n{ return ctx && pose ? ctx->pose(pose) : false; }\r\n\r\nconst char* owlOption(const struct OWLContext *ctx, const char *option)\r\n{ return ctx ? ctx->option(option).c_str() : 0; }\r\n\r\nconst char* owlOptions(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->options().c_str() : 0; }\r\n\r\nbool owlSetOption(struct OWLContext *ctx, const char *option, const char *value)\r\n{ return ctx && option && value ? ctx->option(option, value) : false; }\r\n\r\nbool owlSetOptions(struct OWLContext *ctx, const char *options)\r\n{ return ctx && options ? ctx->options(options) : false; }\r\n\r\nconst char* owlLastError(const struct OWLContext *ctx)\r\n{ return ctx ? ctx->lastError().c_str() : \"error: Invalid context\"; }\r\n\r\n/* Markers */\r\n\r\nbool owlSetMarkerName(struct OWLContext *ctx, uint32_t marker_id, const char *name)\r\n{ return ctx ? ctx->markerName(marker_id, name?name:\"\") : false; }\r\n\r\nbool owlSetMarkerOptions(struct OWLContext *ctx, uint32_t marker_id, const char *marker_options)\r\n{ return ctx && marker_options ? ctx->markerOptions(marker_id, marker_options) : false; }\r\n\r\nconst struct OWLMarkerInfo owlMarkerInfo(const struct OWLContext *ctx, uint32_t marker_id)\r\n{\r\n  if(!ctx) { const OWLMarkerInfo r = { (uint32_t)-1, (uint32_t)-1, 0, 0}; return r; }\r\n  const MarkerInfo &i = ctx->data()->markers[marker_id];\r\n  const OWLMarkerInfo r = { i.id, i.tracker_id, i.name.c_str(), i.options.c_str() }; return r;\r\n}\r\n\r\n/* Trackers */\r\n\r\nbool owlCreateTracker(struct OWLContext *ctx, uint32_t tracker_id, const char *tracker_type,\r\n                      const char *tracker_name, const char *tracker_options)\r\n{\r\n  return ctx && tracker_type ?\r\n    ctx->createTracker(tracker_id, tracker_type, tracker_name?tracker_name:\"\", tracker_options?tracker_options:\"\") :\r\n    false;\r\n}\r\n\r\nbool owlCreateTrackers(struct OWLContext *ctx, const OWLTrackerInfo *info, uint32_t count)\r\n{\r\n  if(!ctx || !info || !count) return false;\r\n  std::vector<TrackerInfo> t;\r\n  for(const OWLTrackerInfo *i = info; i != info+count; i++)\r\n    {\r\n      std::vector<uint32_t> mids;\r\n      if(i->marker_ids && i->marker_ids_end && i->marker_ids != i->marker_ids_end)\r\n\tmids.assign(i->marker_ids, i->marker_ids_end);\r\n      t.push_back(TrackerInfo(i->id, i->type?i->type:\"\", i->name?i->name:\"\", i->options?i->options:\"\", mids));\r\n    }\r\n  return ctx->createTrackers(t.data(), t.data()+t.size());\r\n}\r\n\r\nbool owlDestroyTracker(struct OWLContext *ctx, uint32_t tracker_id)\r\n{ return ctx ? ctx->destroyTracker(tracker_id) : false; }\r\n\r\nbool owlDestroyTrackers(struct OWLContext *ctx, const uint32_t *tracker_ids, uint32_t count)\r\n{ return ctx && tracker_ids && count ? ctx->destroyTrackers(tracker_ids, tracker_ids + count) : false; }\r\n\r\nbool owlTrackerAssignMarker(struct OWLContext *ctx, uint32_t tracker_id, uint32_t marker_id,\r\n                            const char *marker_name, const char *marker_options)\r\n{ return ctx ? ctx->assignMarker(tracker_id, marker_id, marker_name?marker_name:\"\", marker_options?marker_options:\"\") : false; }\r\n\r\nbool owlAssignMarkers(struct OWLContext *ctx, const OWLMarkerInfo *info, uint32_t count)\r\n{\r\n  if(!ctx || !info || !count) return false;\r\n  std::vector<MarkerInfo> m;\r\n  for(const OWLMarkerInfo *i = info; i != info+count; i++)\r\n    m.push_back(MarkerInfo(i->id, i->tracker_id, i->name?i->name:\"\", i->options?i->options:\"\"));\r\n  return ctx->assignMarkers(m.data(), m.data()+m.size());\r\n}\r\n\r\nbool owlSetTrackerName(struct OWLContext *ctx, uint32_t tracker_id, const char *name)\r\n{ return ctx ? ctx->trackerName(tracker_id, name?name:\"\") : false; }\r\n\r\nbool owlSetTrackerOptions(struct OWLContext *ctx, uint32_t tracker_id, const char *tracker_options)\r\n{ return ctx && tracker_options ? ctx->trackerOptions(tracker_id, tracker_options) : false; }\r\n\r\nconst struct OWLTrackerInfo owlTrackerInfo(const struct OWLContext *ctx, uint32_t tracker_id)\r\n{\r\n  if(!ctx || !ctx->data()) { const OWLTrackerInfo r = { (uint32_t)-1, 0, 0, 0, 0, 0}; return r; }\r\n  const TrackerInfo &i = ctx->data()->trackers[tracker_id];\r\n  const OWLTrackerInfo r = { i.id, i.type.c_str(), i.name.c_str(), i.options.c_str(),\r\n                             i.marker_ids.data(), i.marker_ids.data()+i.marker_ids.size() };\r\n  return r;\r\n}\r\n\r\n/* Filters */\r\n\r\nbool owlSetFilter(struct OWLContext *ctx, uint32_t period, const char *name, const char *filter_options)\r\n{ return ctx ? ctx->filter(period, name, filter_options) : false; }\r\n\r\nbool owlSetFilters(struct OWLContext *ctx, const struct OWLFilterInfo *info, uint32_t count)\r\n{\r\n  if(!ctx || !info || !count) return false;\r\n  std::vector<FilterInfo> f;\r\n  for(const OWLFilterInfo *i = info; i != info+count; i++)\r\n    f.push_back(FilterInfo(i->period, i->name, i->options));\r\n  return ctx->filters(f.data(), f.data()+f.size());\r\n}\r\n\r\nconst struct OWLFilterInfo owlFilterInfo(const struct OWLContext *ctx, const char *name)\r\n{\r\n  if(!ctx) { const OWLFilterInfo r = { 0, 0, 0 }; return r; }\r\n  const FilterInfo f = ctx->filterInfo(name);\r\n  const OWLFilterInfo r = { f.period, f.name.c_str(), f.options.c_str() }; return r;\r\n}\r\n\r\n/* Devices */\r\n\r\nconst struct OWLDeviceInfo owlDeviceInfo(const struct OWLContext *ctx, uint64_t hw_id)\r\n{\r\n  if(!ctx || !ctx->data()) { const OWLDeviceInfo r = { 0, 0, 0, 0, 0, 0, 0}; return r; }\r\n  const DeviceInfo &i = ctx->data()->devices[hw_id];\r\n  const OWLDeviceInfo r = { i.hw_id, i.id, i.time, i.type.c_str(), i.name.c_str(), i.options.c_str(), i.status.c_str() };\r\n  return r;\r\n}\r\n\r\n/* Events */\r\n\r\nconst struct OWLEvent* owlPeekEvent(struct OWLContext *ctx, long timeout)\r\n{\r\n  const OWL::Event *e = ctx ? ctx->peekEvent(timeout) : 0;\r\n  return e ? (e->type_id() == Type::FRAME ? copy_frame(e, ctx->event, ctx->frameEvents) : copy_event(e, ctx->event)) : 0;\r\n}\r\n\r\nconst struct OWLEvent* owlNextEvent(struct OWLContext *ctx, long timeout)\r\n{\r\n  const OWL::Event *e = ctx ? ctx->nextEvent(timeout) : 0;\r\n  return e ? (e->type_id() == Type::FRAME ? copy_frame(e, ctx->event, ctx->frameEvents) : copy_event(e, ctx->event)) : 0;\r\n}\r\n\r\nint owlGetString(const struct OWLEvent *e, char *value, uint32_t count)\r\n{\r\n  int ret = get(e, OWL_TYPE_STRING, value, count?count-1:0);\r\n  if(ret > -1 && value) value[ret] = 0;\r\n  return ret;\r\n}\r\n\r\nint owlGetIntegers(const struct OWLEvent *e, int *value, uint32_t count)\r\n{ return get(e, OWL_TYPE_INT, value, count); }\r\n\r\nint owlGetFloats(const struct OWLEvent *e, float *value, uint32_t count)\r\n{ return get(e, OWL_TYPE_FLOAT, value, count); }\r\n\r\nint owlGetCameras(const struct OWLEvent *e, struct OWLCamera *cameras, uint32_t count)\r\n{ return get(e, OWL_TYPE_CAMERA, cameras, count); }\r\n\r\nint owlGetPeaks(const struct OWLEvent *e, struct OWLPeak *peaks, uint32_t count)\r\n{ return get(e, OWL_TYPE_PEAK, peaks, count); }\r\n\r\nint owlGetPlanes(const struct OWLEvent *e, struct OWLPlane *planes, uint32_t count)\r\n{ return get(e, OWL_TYPE_PLANE, planes, count); }\r\n\r\nint owlGetMarkers(const struct OWLEvent *e, struct OWLMarker *markers, uint32_t count)\r\n{ return get(e, OWL_TYPE_MARKER, markers, count); }\r\n\r\nint owlGetRigids(const struct OWLEvent *e, struct OWLRigid *rigids, uint32_t count)\r\n{ return get(e, OWL_TYPE_RIGID, rigids, count); }\r\n\r\nint owlGetInputs(const struct OWLEvent *e, struct OWLInput *inputs, uint32_t count)\r\n{ return get(e, OWL_TYPE_INPUT, inputs, count); }\r\n\r\nconst struct OWLEvent* owlFindEvent(const struct OWLEvent *event, uint16_t type_id, const char *name)\r\n{\r\n  if(event == 0 || (type_id == 0 && name == 0)) return 0;\r\n  if((type_id == 0 || type_id == event->type_id) && (name == 0 || strcmp(name, event->name) == 0)) return event;\r\n  if(event->type_id != OWL_TYPE_FRAME) return 0;\r\n  for(const OWLEvent *e = (const OWLEvent*)event->data; e != (const OWLEvent*)event->data_end; e++)\r\n    if(e && (type_id == 0 || type_id == e->type_id) && (name == 0 || strcmp(name, e->name) == 0))\r\n      return e;\r\n  return 0;\r\n}\r\n\r\n/* Property */\r\n\r\nconst char* owlProperty(const struct OWLContext *ctx, const char *name)\r\n{ return ctx && name ? (const char*)ctx->property(name) : 0; }\r\n\r\nint owlPropertyi(const struct OWLContext *ctx, const char *name)\r\n{ return ctx && name ? (int)ctx->property(name) : 0; }\r\n\r\nfloat owlPropertyf(const struct OWLContext *ctx, const char *name)\r\n{ return ctx && name ? (float)ctx->property(name) : 0; }\r\n\r\nint owlPropertyiv(const struct OWLContext *ctx, const char *name, int *value, uint32_t count)\r\n{ return ctx && name ? get(ctx->property(name), OWL_TYPE_INT, value, count) : -1; }\r\n\r\nint owlPropertyfv(const struct OWLContext *ctx, const char *name, float *value, uint32_t count)\r\n{ return ctx && name ? get(ctx->property(name), OWL_TYPE_FLOAT, value, count) : -1; }\r\n\r\n#endif // _MSC_VER > 1600\r\n\r\n////\r\n"},{"name":"libowl_socket.cpp","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\Custom_Library\\PhaseSpase_Cameras\\PHASESPACE\\src","tag":"","groupDisplay":"Other files","code":"/***\r\nCopyright (c) PhaseSpace, Inc 2016\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL PHASESPACE, INC\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n***/\r\n\r\n// libowl_socket.cc -*- C++ -*-\r\n// OWL C++ API v2.0\r\n// owl socket device\r\n\r\n#include <iostream>\r\n\r\n#ifndef WIN32\r\n#include <unistd.h>\r\n#else // WIN32\r\n#include <winsock2.h>\r\n#endif // WIN32\r\n\r\n#include \"socket.h\"\r\n#include \"libowl.h\"\r\n#include \"packet.h\"\r\n#include \"protocol.h\"\r\n#include \"serialize.h\"\r\n\r\nusing namespace std;\r\n\r\ninline std::ostream& operator<<(std::ostream &out, const OWL::Header &h)\r\n{ return out << std::hex << (int)h.type << \" \" << (int)h.id << \" \" << (int)h.cksum  << std::dec << \" s=\" << h.size << \" t=\" << h.time; }\r\n\r\nnamespace OWL {\r\n\r\n  enum { CONNECTED = 0x1 };\r\n  enum { INITIALIZE = 4, DONE = 5, STREAMING = 6 }; // from core and emul\r\n\r\n  //// SocketDevice ////\r\n\r\n  class SocketDevice : public Device {\r\n\r\n    struct Frame : std::vector<Event> {\r\n      uint16_t id;\r\n      int64_t time;\r\n\r\n      Frame(uint16_t id=0, int64_t time=-1) : std::vector<Event>(), id(id), time(time) { }\r\n    };\r\n\r\n    int port;\r\n\r\n    selector select;\r\n    tcp_socket sock; // blocking\r\n    udp_socket udp;\r\n    udp_socket broadcast;\r\n\r\n    Frame newFrame;\r\n\r\n    ostringstream err;\r\n\r\n    std::vector<char> buffer;\r\n\r\n  public:\r\n\r\n    SocketDevice() : port(0)\r\n    {\r\n      sock.verbose = 1;\r\n      sock.out = 0;\r\n      sock.err = &err;\r\n      udp.verbose = 1;\r\n      udp.out = 0;\r\n      udp.err = &err;\r\n      broadcast.verbose = 1;\r\n      broadcast.out = 0;\r\n      broadcast.err = &err;\r\n      WINSOCK_INIT();\r\n    }\r\n\r\n    ~SocketDevice()\r\n    {\r\n      close();\r\n      WINSOCK_DONE();\r\n    }\r\n\r\n    int open(const std::string &device, const std::string &device_options)\r\n    {\r\n      if(sock && sock.getf(CONNECTED)) return 1;\r\n\r\n      strings a = split(device, ':');\r\n      stringmap o(device_options);\r\n\r\n      const char *addr = a.size() > 0 && !a[0].empty() ? a[0].c_str() : \"localhost\";\r\n      port = a.size() > 1 ? strtoi(a[1]) : 0;\r\n      int t = get(o, \"timeout\", int(3000000));\r\n\r\n      if(!sock)\r\n        {\r\n          int ret = sock.connect(addr, 8000+port, t);\r\n          update_error();\r\n          if(ret <= 0) return ret;\r\n        }\r\n      else if(!sock.getf(CONNECTED))\r\n        {\r\n          int ret = sock.connected(t);\r\n          update_error();\r\n          if(ret <= 0) return ret;\r\n        }\r\n\r\n      { // use tcp socket's port# as udp port#\r\n        int port = 0;\r\n        if(const char *address = sock.getsaddr(&port)) udp.bind(address, port);\r\n      }\r\n\r\n      sock.recv_bufsize(16*1024*1024);\r\n      sock.send_bufsize(16*1024*1024);\r\n\r\n      sock.nonblock(false);\r\n      sock.setf(CONNECTED);\r\n      update_error();\r\n\r\n      time = -1;\r\n\r\n      return 1;\r\n    }\r\n\r\n    bool close()\r\n    {\r\n      if(!sock) return false;\r\n      events.clear();\r\n\r\n      sock.close();\r\n      udp.close();\r\n      broadcast.close();\r\n\r\n      sock.clear();\r\n      udp.clear();\r\n      broadcast.clear();\r\n\r\n      update_error();\r\n\r\n      return true;\r\n    }\r\n\r\n    bool is_open() const\r\n    { return sock ? sock.getf(CONNECTED) : false; }\r\n\r\n    int read(long timeout)\r\n    {\r\n      select.clear() << sock.sock() << udp.sock() << broadcast.sock();\r\n      timeval tv = {timeout / 1000000, timeout % 1000000};\r\n      int ret = select(tv, 1);\r\n      if(ret <= 0) return ret;\r\n\r\n      ret = 0;\r\n      while(sock && sock.select(0, 1) > 0 && recv(sock) > 0) ret++;\r\n      while(udp && udp.select(0, 1) > 0 && recv(udp) > 0) ret++;\r\n      while(broadcast && broadcast.select(0, 1) > 0 && recv(broadcast) > 0) ret++;\r\n\r\n      return ret ? ret : (sock ? 0 : -1);\r\n    }\r\n\r\n    int recv(basic_socket &s)\r\n    {\r\n      Header h;\r\n      packet p;\r\n\r\n      int ret = OWL::recv(s, h, p);\r\n      update_error();\r\n      if(ret <= 0) return ret;\r\n\r\n      int count = 0;\r\n      // multi-message packet\r\n      while(p.index <= p.size())\r\n        {\r\n          ret = recv(h, p);\r\n          if(ret <= 0) return ret;\r\n          count++;\r\n          p.index += h.size;\r\n\r\n          if(p.size() < p.index + sizeof(Header)) break;\r\n          h = *(Header*)(p.data()+p.index);\r\n          p.index += sizeof(Header);\r\n        }\r\n      return count;\r\n    }\r\n\r\n    int recv(Header &h, packet &p)\r\n    {\r\n      if(time < h.time) time = h.time;\r\n\r\n      if(h.type == Type::BYTE && (h.id == INITIALIZE || h.id == DONE))\r\n        {\r\n          stringmap m(string(p.data()+p.index, h.size));\r\n          vector<int> n;\r\n          if(get(m, \"streaming\", n)) toggle_broadcast(n[0]);\r\n        }\r\n      else if(h.type == Type::INT && h.id == STREAMING && h.size == 4)\r\n        {\r\n          const int *v = (const int*)(p.data()+p.index);\r\n          toggle_broadcast(*v);\r\n        }\r\n\r\n      // frame events have frame id and event ids for transmission: (frame.id << 8) | event.id\r\n      uint16_t frame_id = (h.id >> 8);\r\n      if(frame_id)\r\n        {\r\n          // accumulate frame events\r\n          if(frame_id != newFrame.id || h.time != newFrame.time) newFrame = Frame(frame_id, h.time);\r\n          newFrame.push_back(decode(p, h.size, h.type, (h.id & 0xFF), 0, h.time));\r\n          if(!newFrame.back().valid()) { newFrame.pop_back(); return 0; }\r\n        }\r\n      else if(h.type == Type::FRAME && (p.size() <= p.index) && h.id == newFrame.id && h.time == newFrame.time)\r\n        {\r\n          // copy frame events into frame\r\n          events.push_back(EventPrivate(h.type, h.id, 0, h.time, newFrame));\r\n          newFrame = Frame();\r\n        }\r\n      else\r\n        {\r\n          events.push_back(decode(p, h.size, h.type, h.id, 0, h.time));\r\n          if(!events.back().valid()) { events.pop_back(); return 0; }\r\n        }\r\n\r\n      return 1;\r\n    }\r\n\r\n    int write(uint16_t type, uint16_t id, uint32_t flags, const char *data, size_t size)\r\n    {\r\n      if(!sock || !valid(id)) return -1;\r\n\r\n      Header h(type, id, size);\r\n\r\n      buffer.clear();\r\n      buffer.insert(buffer.end(), (const char*)&h, (const char*)(&h+1));\r\n      if(size) buffer.insert(buffer.end(), data, data+size);\r\n\r\n      int ret = sock.send(buffer.data(), buffer.size());\r\n      update_error();\r\n      if(ret != (int)buffer.size()) return -1;\r\n\r\n      return ret;\r\n    }\r\n\r\n    void update_error()\r\n    {\r\n      error = err.str();\r\n      err.str(\"\");\r\n      if(!error.empty() && error[error.size()-1] == '\\n') error.erase(error.size()-1);\r\n    }\r\n\r\n    void toggle_broadcast(int v)\r\n    {\r\n      if(v == 3 && !broadcast)\r\n        {\r\n          broadcast.listen(8500+port);\r\n          broadcast.nonblock();\r\n          broadcast.broadcast(1);\r\n          broadcast.recv_bufsize(16*1024*1024);\r\n          broadcast.send_bufsize(16*1024*1024);\r\n        }\r\n      else if(v != 3 && broadcast) broadcast.close();\r\n      update_error();\r\n    }\r\n\r\n    static SocketDevice* create() { return new SocketDevice(); }\r\n\r\n  }; // SocketDevice\r\n\r\n  Device* Device::create() { return new SocketDevice(); }\r\n\r\n  //// Scan ////\r\n\r\n  Scan::Scan() : fd(-1)\r\n  {\r\n    WINSOCK_INIT();\r\n  }\r\n\r\n  Scan::~Scan()\r\n  {\r\n    udp_socket sock(fd);\r\n    sock.verbose = 0;\r\n    sock.close();\r\n    fd = -1;\r\n    WINSOCK_DONE();\r\n  }\r\n\r\n  bool Scan::send(const std::string &message)\r\n  {\r\n    udp_socket sock(fd);\r\n    sock.verbose = 0;\r\n    if(!sock)\r\n      {\r\n        sock.socket();\r\n        if(!sock) return false;\r\n        sock.nonblock();\r\n        sock.broadcast(1);\r\n        fd = sock.sock();\r\n      }\r\n    sock.setoaddr(0, 8998);\r\n\r\n    // format message?\r\n    ostring out;\r\n    char name[1024] = \"\";\r\n    gethostname(name, sizeof(name));\r\n    out << \"hostname=\" << name;\r\n    out << \" protocol=\" << int(OWL_PROTOCOL_VERSION);\r\n#ifdef LIBOWL_REV\r\n    out << \" libowl=5.1.\" << LIBOWL_REV;\r\n#endif // LIBOWL_REV\r\n    if(!message.empty()) out << \" \" << message;\r\n    string s = out;\r\n    bool ret = sock.send(s.c_str(), s.size()+1) > 0;\r\n    if(!sock) fd = -1;\r\n    return ret;\r\n  }\r\n\r\n  std::vector<std::string> Scan::listen(long timeout)\r\n  {\r\n    std::vector<std::string> out;\r\n    udp_socket sock(fd);\r\n    sock.verbose = 0;\r\n    if(!sock) return out;\r\n\r\n    int ret = sock.select(timeout, 1);\r\n    if(!sock) fd = -1;\r\n    if(ret <= 0) return out;\r\n\r\n    vector<Event> events;\r\n    char buf[9*1024];\r\n    while(1)\r\n      {\r\n        ret = sock.recv(buf, sizeof(buf));\r\n        if(!sock) fd = -1;\r\n        if(ret <= 0) break;\r\n        buf[ret] = 0;\r\n\r\n        const char *iaddr = sock.getiaddr();\r\n        if(!iaddr) continue;\r\n\r\n        out.push_back(string(\"ip=\") + iaddr + \" \" + buf);\r\n      }\r\n\r\n    return out;\r\n  }\r\n  ////\r\n\r\n} // namespace OWL\r\n"},{"name":"linuxUDP.c","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2022a\\toolbox\\realtime\\targets\\raspi\\src\\udp","tag":"","groupDisplay":"Other files","code":"/**\n * @file linuxUDP.c\n * Copyright 2009-2017 The MathWorks, Inc.\n */\n\n#include <assert.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <fcntl.h>\n#include \"rtwtypes.h\"\n\n/* BEGIN INLINE OF #include \"DAHostLib_Network.h\" */\n\n/* Wrap everything in extern C */\n#ifdef __cplusplus\nextern \"C\" {\n#endif \n\nextern const char *libName_Network;\n\ntypedef enum {\n    NETWORK_INPUT  = 0,\n    NETWORK_OUTPUT = 1\n} NetworkInputOrOutput;\n\n/*******************************\n * Routines which are defined in the library in question\n *******************************/\ntypedef void (*pFnLibCreate_Network)(void **device, char *err, NetworkInputOrOutput inOut, const char *localURL, int localPort, \n                             const char *remoteURL, int remotePort, int bufferSize, int bytesPerSample, int blockingTime);\ntypedef void (*pFnLibUpdate_Network)(void *device, char *err, const void *src, int nSamples);\ntypedef void (*pFnLibOutputs_Network)(void *device, char *err, void *src, int* nSamples);\n\n/*******************************\n * Routines which we define to call the functions in the library \n *******************************/\n\nvoid CreateUDPInterface(void *hl);\nvoid DestroyUDPInterface(void *hl);\n\nvoid LibCreate_Network(void *hostLib, int inOut, const char *localURL, int localPort, \n                       const char *remoteURL, int remotePort, int bufferSize, int bytesPerSample, int blockingTime);\nvoid LibUpdate_Network(void *hostLib, const void *src, int nSamples);\nvoid LibOutputs_Network(void *hostLib, void *src, int *nSamples);\n\n/* Include HostLib for declarations of LibStart, LibTerminate, CreateHostLibrary, and DestroyHostLibrary. */\n#include \"DAHostLib_rtw.h\"\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif \n\n/* END INLINE OF #include \"DAHostLib_Network.h\" */\n\n\ntypedef struct tgtsockstruct {\n    int sockfd;\n    struct sockaddr_in localsockaddr;\n    struct sockaddr_in remotesockaddr;\n    int dataTypeSize;\n} TgtSockStructT;\n\n\nvoid TGT_libCreate(void **device_, char *err, NetworkInputOrOutput io,\n        const char *localURL, int localPort, const char *remoteURL,\n        int remotePort, int bufferSize, int dataTypeSize, int blockingTime);\nvoid TGT_libUpdate(void *device, char *err, const void *src, int nSamples);\nvoid TGT_libStart(void *device, char *err);\nvoid TGT_libOutputs(void *device, char *err, void *src, int *nSamples);\nvoid TGT_libTerminate(void *device, char *err);\nvoid TGT_libDestroy(void *device, char *err, int type);\n\n\nvoid CreateTargetUDPInterface(void *hl)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    *hostLib->errorMessage = '\\0';\n    memset(hostLib, 0, sizeof(HostLibrary));\n    \n    /* Indicate that the structure is valid for future function calls. */\n    hostLib->library      = (void*) 1;\n    \n    /* Set the function pointers to point to target UDP implementation. */\n    hostLib->libCreate    = (void*) TGT_libCreate;\n    hostLib->libStart     = (void*) TGT_libStart;\n    hostLib->libReset     = (void*) NULL;\n    hostLib->libUpdate    = (void*) TGT_libUpdate;\n    hostLib->libOutputs   = (void*) TGT_libOutputs;\n    hostLib->libTerminate = (void*) TGT_libTerminate;\n    hostLib->libDestroy   = (void*) TGT_libDestroy;\n}\n\n\nvoid DestroyTargetUDPInterface(void *hl)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->library) {\n        /* Clear the structure (except for any possible error message). */\n        memset(hostLib, 0, sizeof(HostLibrary) - MAX_ERR_MSG_LEN);\n    }\n}\n\n\nvoid TGT_libCreate(void **device_, char *err, NetworkInputOrOutput io,\n        const char *localURL, int localPort, const char *remoteURL,\n        int remotePort, int bufferSize, int dataTypeSize, int blockingTime)\n{\n    int flags;\n    struct timeval tv;\n    int ret;\n    TgtSockStructT *device;\n    /* verification of the local port*/\n    /* case it lower than zero, assign to zero so it can dynamically assigned */\n    if(localPort < 0) {\n        localPort = 0;\n    }\n    device = (TgtSockStructT *) malloc (sizeof(TgtSockStructT));\n    \n    \n    bzero(&device->remotesockaddr, sizeof(device->remotesockaddr));\n    device->remotesockaddr.sin_family = AF_INET;\n    device->remotesockaddr.sin_port = htons(remotePort);\n    \n    inet_aton(remoteURL, &device->remotesockaddr.sin_addr);\n    \n    bzero(&device->localsockaddr, sizeof(device->localsockaddr));\n    device->localsockaddr.sin_family = AF_INET;\n    device->localsockaddr.sin_port = htons(localPort);\n    inet_aton(localURL, &device->localsockaddr.sin_addr);\n    \n    device->sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if ( device->sockfd < 0) {\n        printf (\"error creating socket\\n\");\n    }\n    if ((device->remotesockaddr.sin_addr.s_addr == INADDR_BROADCAST) ||\n            (device->localsockaddr.sin_addr.s_addr == INADDR_BROADCAST)) {\n        static int broadcast_en = 1;\n        ret = setsockopt(((TgtSockStructT *) device)->sockfd, SOL_SOCKET,\n                SO_BROADCAST, &broadcast_en, sizeof(broadcast_en));\n        if (ret < 0) {\n            perror(\"ERROR in SO_BROADCAST\");\n        }\n    }\n    \n    if ( io == NETWORK_INPUT) {\n        ret = setsockopt(((TgtSockStructT *) device)->sockfd, SOL_SOCKET,\n                SO_RCVBUF, &bufferSize, sizeof(bufferSize));\n    }\n    else if (io == NETWORK_OUTPUT) {\n        ret = setsockopt(((TgtSockStructT *) device)->sockfd, SOL_SOCKET,\n                SO_SNDBUF, &bufferSize, sizeof(bufferSize));\n    }\n    else {\n        ret  = -1;\n        perror(\"INVALID NetworkIOValue\");\n    }\n    \n    if (ret < 0) {\n        perror(\"ERROR in setsockopt\");\n    }\n    else{\n        int realSize = 0;\n        int len = sizeof(realSize);\n        \n        if (io == NETWORK_INPUT) {\n            getsockopt(((TgtSockStructT *) device)->sockfd,SOL_SOCKET,SO_RCVBUF,&realSize, &len);\n        }\n        else {\n            getsockopt(((TgtSockStructT *) device)->sockfd,SOL_SOCKET,SO_SNDBUF,&realSize, &len);\n        }\n        if (realSize < bufferSize) {\n            fprintf(stderr, \"Buffer requested size: %d Bytes. Socket buffer limit: %d Bytes\\n\",bufferSize,realSize);\n        }\n    }\n    \n    if(blockingTime == 0) {\n        /* set non-blocking socket option */\n        flags = fcntl(((TgtSockStructT *) device)->sockfd, F_GETFL, 0);\n        fcntl(((TgtSockStructT *) device)->sockfd, F_SETFL, flags | O_NONBLOCK);\n    }\n    else if(blockingTime != MIN_int32_T) {\n        /* if not set to inf in the block mask */\n        tv.tv_sec  = (long) (blockingTime/1000);\n        tv.tv_usec = (long) (blockingTime % 1000);\n        setsockopt(((TgtSockStructT *) device)->sockfd, SOL_SOCKET,\n                SO_RCVTIMEO, &tv, sizeof(tv));\n    }\n    device->dataTypeSize = dataTypeSize;\n    *device_ = device;\n    err[0] = '\\0';\n}\n\n\nvoid TGT_libStart(void *device, char *err)\n{\n    if(device) {\n        bind(((TgtSockStructT *) device)->sockfd,\n                (struct sockaddr *) &((TgtSockStructT *) device)->localsockaddr,\n                sizeof(((TgtSockStructT *) device)->localsockaddr));\n    }\n}\n\n\nvoid TGT_libUpdate(void *device, char *err, const void *src, int nSamples)\n{\n    int n;\n    \n    if(device) {\n        n = sendto(((TgtSockStructT *) device)->sockfd, src,\n                ((TgtSockStructT *) device)->dataTypeSize * nSamples, 0,\n                (struct sockaddr *) &((TgtSockStructT *) device)->remotesockaddr,\n                sizeof(((TgtSockStructT *) device)->remotesockaddr));\n        /* if(n<0)\n         * printf(\"error writing to socket\\n\");\n         */\n    }\n}\n\n\nvoid TGT_libOutputs(void *device, char *err, void *src, int *nSamples)\n{\n    int numBytesReceived = 0;\n    int dTypeSize = ((TgtSockStructT *)device)->dataTypeSize;\n    size_t nBytesToRead = dTypeSize * (*nSamples);\n    if(device) {\n        numBytesReceived = recvfrom(((TgtSockStructT *) device)->sockfd, src, nBytesToRead, 0, NULL, NULL);\n        if (numBytesReceived > 0) {\n            *nSamples = (int) (numBytesReceived / dTypeSize); /* Return number of bytes received */\n        }\n        else {\n            *nSamples = 0; /* No UDP packets received */\n        }\n    }\n}\n\n\nvoid TGT_libTerminate(void *device, char *err)\n{\n    /* NOP; */\n}\n\n\nvoid TGT_libDestroy(void *device, char *err, int type)\n{\n    if(device) {\n        free(device);\n    }\n}\n"},{"name":"linuxinitialize.cpp","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2022a\\toolbox\\target\\codertarget\\rtos\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2013-2020 The MathWorks, Inc. */\n\n\n/* ---------------------------- */\n/* RTOS-specific headers        */\n/* Note: must be included first */\n/* ---------------------------- */\n#include \"linuxinitialize.h\"\n#include \"rtwtypes.h\"\n/* ---------------------------- */\n/* Required Coder Target header */\n/* ---------------------------- */\n#include \"MW_custom_RTOS_header.h\"\n\n#if defined(MW_SOC_ENABLED) && defined(MW_KERNEL_PROFILING_ON)   \n#include \"kernelprofiler-tp.h\"\n#endif\n\n#define NAMELEN 16\n\ntypedef struct {\n    void* (*pAsyncTasks)(void* arg);\n    char taskName[NAMELEN];\n    int priority;\n    int policy;\n    int coreSelection;\n    int coreNum;\n} MW_AsyncTaskCodeGenInfo_Type;\n\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\nstatic MW_AsyncTaskCodeGenInfo_Type asyncTaskCodeGenInfo[MW_TSKMGR_EVENT_DRIVEN_TASKS];\n\nvoid mw_setAsyncTaskCodeGenInfo(void * (*taskHandler)(void *), \n        const char* taskName, int priority, int policy, \n        int coreSelection, int coreNum, int idx)\n{\n    asyncTaskCodeGenInfo[idx].pAsyncTasks = taskHandler;\n    snprintf(asyncTaskCodeGenInfo[idx].taskName, NAMELEN, \"%s\", taskName);\n    asyncTaskCodeGenInfo[idx].priority = priority;\n    asyncTaskCodeGenInfo[idx].policy = policy;\n    asyncTaskCodeGenInfo[idx].coreSelection = coreSelection;\n    asyncTaskCodeGenInfo[idx].coreNum = coreNum;\n}\n#endif\nextern volatile boolean_T runModel;\n/* ---------------------------- */\n/* RTOS-specific declarations   */\n/* ---------------------------- */\ntypedef struct {\n    double period;\n} baseRateInfo_t;\n\npthread_t baseTimerThread;\n\npthread_attr_t attr;\nbaseRateInfo_t info;\nstruct sched_param sp;\n\n/* MW_NUM_SUBRATES is set to 0 if we are in single-tasking mode or number of subrates are 0 */\n#define MW_SP_SCHED_FIFO   ((MW_NUMBER_SUBRATES > 0) || !defined(MW_SCHED_OTHER))\n#ifdef MW_RTOS_DEBUG\n    #define MW_DEBUG_LOG(str)  printf(str); fflush(stdout)\n#else\n    #define MW_DEBUG_LOG(str)\n#endif\n\n#ifdef MW_HAS_COMM_SERVICE\n    extern int makeCSTaskIdle();\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n    sem_t timerTaskSem[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    int timer_fd[MW_NUMBER_TIMER_DRIVEN_TASKS];\n    double timer_period[MW_NUMBER_TIMER_DRIVEN_TASKS];\n#endif\n    \nint mw_CreateArmedTimer(double periodInSeconds)\n{\n    int status;\n    int fd;\n    struct itimerspec its;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }\n\n    /* Make the timer periodic */\n    its.it_value.tv_sec = (time_t)periodInSeconds;\n    its.it_value.tv_nsec = (periodInSeconds - (time_t)periodInSeconds) * 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timerfd_settime(fd, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n    \n    return fd;\n}\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_init_timerTaskSem(int idx)\n{\n    int status;\n    status = sem_init(&timerTaskSem[idx], 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:mw_init_timerTaskSem\");\n}\n\nint mw_CreateUnarmedTimer(double periodInSeconds, int idx)\n{\n    int fd;\n    int status;\n\n    /* Create the timer */\n    fd = timerfd_create(CLOCK_MONOTONIC, 0);\n    timer_fd[idx] = fd;\n    timer_period[idx] = periodInSeconds;\n    if (fd == -1) {\n        fprintf(stderr, \"Call to timerfd_create failed.\\n\"); \n        perror(\"timerfd_create\");\n        fflush(stderr); \n        exit(EXIT_FAILURE);\n    }     \n    /* Signal that the timer has been created. */\n    status = sem_post(&timerTaskSem[idx]); \n    CHECK_STATUS(status, 0, \"sem_post:mw_CreateUnarmedTimer\");     \n    #ifdef MW_RTOS_DEBUG\n        printf(\"Created unarmed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif    \n    return fd;\n}\n#endif\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\nvoid mw_ArmTimer(int idx)\n{\n    int status;\n    struct itimerspec its;\n    int fd = timer_fd[idx];\n    double periodInSeconds = timer_period[idx];\n    \n    its.it_interval.tv_sec = (time_t)periodInSeconds;\n    its.it_interval.tv_nsec = (periodInSeconds - (time_t)periodInSeconds) * 1000000000;\n    its.it_value.tv_sec = 0;\n    its.it_value.tv_nsec = 1.0;\n    #ifdef MW_RTOS_DEBUG\n        printf(\"About to arm timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    status = timerfd_settime(fd, 0, &its, NULL);\n    #ifdef MW_RTOS_DEBUG\n        printf(\"Armed timer # %d %d.\\n\", fd, idx);\n        fflush(stdout);\n    #endif\n    \n    CHECK_STATUS(status, 0, \"timer_settime\"); \n}\n#endif\n\nvoid mw_WaitForTimerEvent(int fd)\n{\n    unsigned long long missed;\n    int status;\n    \n    /* Wait for the next timer event. If we have missed any the\n       number is written to \"missed\" */\n    while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    if (status == -1) {\n        perror(\"read(timerfd)\");\n    }\n}\n\nvoid mw_WaitForTimerEventCatchup(int fd)\n{\n    unsigned long long missed = 0;\n    int status = 0;\n    static unsigned int outstanding = 0;\n    \n    /* Wait for the next timer event. If we have missed any the\n     * number is written to \"missed\" */\n    if (outstanding == 0)\n    {\n        while ((status = read(fd, &missed, sizeof(missed)) == -1) && (errno == EINTR)) {\n            /* Restart if interrupted by a signal */\n            continue;\n        }\n        if (status == -1) {\n            perror(\"read(timerfd)\");\n        }\n        if (missed > 1) {\n            #ifdef MW_RTOS_DEBUG\n            printf(\"Missed %llu events for the timer # %d.\\n\", missed, fd);\n            fflush(stdout);\n            #endif\n            outstanding = outstanding + missed - 1;\n        }\n    }\n    else\n    {\n        #ifdef MW_RTOS_DEBUG\n        printf(\"Catching up with the missed events for timer # %d.\\n\", fd);\n        fflush(stdout);\n        #endif\n        outstanding--;\n    }\n}\n\n/* ---------------------------- */\n/* Internally visible functions */\n/* ---------------------------- */\n\n\n#ifdef MW_SOC_ENABLED\nvoid *baseTimerTask(void* arg)\n{\n    /* SOCB product installed and used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"schedulerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);  \n    SOCB_RateCounterFcn();   \n    while(1) {\n        mw_WaitForTimerEvent(fd);\n        SOCB_RateCounterFcn();\n    }\n}\n#else \nvoid *schedulerTask(void* arg)\n{\n    /* SOCB product not installed or not used */\n    int fd;\n    baseRateInfo_t info = *((baseRateInfo_t *)arg);\n\n    MW_DEBUG_LOG(\"schedulerTask entered\\n\");\n    fd = mw_CreateArmedTimer(info.period);\n    sem_post(&baserateTaskSem); \n    while(runModel) {\n        mw_WaitForTimerEvent(fd);\n        #ifdef DETECT_OVERRUNS        \n            testForRateOverrun(0);\n        #endif\n        sem_post(&baserateTaskSem);\n    }\n}\n\n#ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\nvoid *schedulerTaskALSA(void* arg)\n{\n    /*Register the ALSA Audio capture block with base rate */\n    mw_alsa_registerCallback();\n}\n\nvoid triggerBaseRate(){\n    /*Post the semaphore after period event from ALSA block*/\n    sem_post(&baserateTaskSem);\n}\n#endif\n#endif\n\n\n/* Should use this fcn, but currently are not using it */\n/* Why: it is safe ??? from interruption */\nvoid my_sem_wait(sem_t *sem)\n{\n    int status;\n    while (((status = sem_wait(sem)) == -1) && (errno == EINTR)) {\n        /* Restart if interrupted by a signal */\n        continue;\n    }\n    CHECK_STATUS(status, 0, \"my_sem_wait\");\n}\n\nstatic void setThreadPriority(const int priority, pthread_attr_t *attr, struct sched_param *sp)\n{\n#if MW_SP_SCHED_FIFO\n    int status;\n    \n    sp->sched_priority = priority;\n    status = pthread_attr_setschedparam(attr, sp);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\n\nvoid mw_CreateTask(void * (*taskHandler)(void *), const char* taskName, int priority, int policy, int coreSelection, int coreNum)\n{\n    int status;\n    int inherit;\n    pthread_attr_t attr;\n    pthread_t thread;\n    struct sched_param param;\n    size_t stackSize;\n    pthread_attr_init(&attr);\n    cpu_set_t cpuset;\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n    /* Set thread inherit attribute */\n    inherit = PTHREAD_EXPLICIT_SCHED;\n    status = pthread_attr_setinheritsched(&attr, inherit);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n\n    /* Set thread detach attribute */\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size attribute */\n    stackSize = (512 > PTHREAD_STACK_MIN) ? 512:PTHREAD_STACK_MIN;\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n\n    /* Set thread schedule policy attribute */\n    policy = SCHED_FIFO;\n    status = pthread_attr_setschedpolicy(&attr, policy);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n\n    /* Set thread priority attribute */\n    param.sched_priority = priority;\n    status = pthread_attr_setschedparam(&attr, &param);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n    \n    /* Set the thread core affinity */\n    if (2 == coreSelection) \n    {\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreNum, &cpuset);\n        status =  pthread_attr_setaffinity_np(&attr, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_attr_setaffinity_np\");\n    }\n\n    /* Create the thread */\n    status = pthread_create(&thread, &attr, taskHandler, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", taskName);\n    status = pthread_setname_np(thread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at mw_CreateTask\");\n#endif\n    pthread_attr_destroy(&attr);\n}\n\nvoid myAddBlockForThisEvent(int sigNo)\n{\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid myAddHandlerForThisEvent(int sigNo, int sigToBlock[], int numSigToBlock, void (*sigHandler)(int))\n{\n    int idx;\n    int status;\n    struct sigaction sa;\n\n    sa.sa_handler = (__sighandler_t) sigHandler;\n    sigemptyset(&sa.sa_mask);\n    for (idx=0; idx<numSigToBlock; idx++) {\n            sigaddset(&sa.sa_mask, sigToBlock[idx]);\n    }\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to register a signal handler\");\n}\n\nvoid myRestoreDefaultHandlerForThisEvent(int sigNo)\n{\n    int status;\n    struct sigaction sa;\n    sa.sa_handler = SIG_DFL;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */\n    status = sigaction(sigNo, &sa, NULL);\n    CHECK_STATUS_NOT(status, -1, \"sigaction to restore default signal handler\");\n}\n\n/* ***********************************************************************/\n/* ***********************************************************************/\n/* ***********************************************************************/\n\nvoid myRTOSInit(double baseRatePeriod, int numSubrates)\n{\n    int i;\n    int status;\n    uid_t euid;\n    size_t stackSize;\n    unsigned long cpuMask = 0x1;\n    unsigned int len = sizeof(cpuMask);  \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    char thisTaskName[MW_MAX_TASKNAME];\n#endif\n\n#if (defined(MW_TSKMGR_EVENT_DRIVEN_TASKS) && (MW_TSKMGR_EVENT_DRIVEN_TASKS > 0))\n    {\n        int idx;\n        for (idx=0;idx < MW_TSKMGR_EVENT_DRIVEN_TASKS;idx++)\n        {\n            mw_CreateTask(asyncTaskCodeGenInfo[idx].pAsyncTasks, \\\n                    (const char*) asyncTaskCodeGenInfo[idx].taskName,\\\n                    asyncTaskCodeGenInfo[idx].priority, \\\n                    asyncTaskCodeGenInfo[idx].policy, \\\n                    asyncTaskCodeGenInfo[idx].coreSelection, \\\n                    asyncTaskCodeGenInfo[idx].coreNum);\n        }\n    }\n#endif\n    UNUSED(baseRatePeriod);\n    UNUSED(numSubrates);\n        \n    if (!MW_IS_CONCURRENT) {\n        /* All threads created by this process will run on a single CPU */\n        status = sched_setaffinity(0, len, (cpu_set_t *) &cpuMask);\n        CHECK_STATUS(status, 0, \"sched_setaffinity\");\n    }\n\n#if MW_SP_SCHED_FIFO && !defined (_POSIX_THREAD_PRIORITY_SCHEDULING)\n    fprintf(stderr, \"Priority scheduling is NOT supported by your system.\\n\");\n    fprintf(stderr, \"The generated code will not run correctly because your\\n\");\n    fprintf(stderr, \"model contains multiple rates and uses multi-tasking\\n\");\n    fprintf(stderr, \"code generation mode. You can only run the generated code\\n\");\n    fprintf(stderr, \"in single-tasking mode in your system. Open\\n\");\n    fprintf(stderr, \"Simulation -> Configuration Parameters -> Solver dialog\\n\");\n    fprintf(stderr, \"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\\n\");\n    fprintf(stderr, \"Re-build the Simulink model with the new settings and try executing the generated code again.\\n\");\n    fflush(stderr);\n    exit(EXIT_FAILURE);\n#endif\n    \n#if MW_SP_SCHED_FIFO\n    /* Need root privileges for real-time scheduling */\n    euid = geteuid();\n    if (euid != 0) {\n        fprintf(stderr, \"You must have root privileges to run the generated code because\\n\");\n        fprintf(stderr, \"generated code requires SCHED_FIFO scheduling class to run correctly.\\n\");\n        fprintf(stderr, \"Try running the executable with the following command: sudo ./<executable name>\\n\");\n        fflush(stderr);\n        exit(EXIT_FAILURE);\n    }\n#endif\n\n    status = sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:baserateTaskSemSem\");\n    status = sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"sem_init:stopSem\");\n    \n#if MW_SP_SCHED_FIFO\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    sp.sched_priority = sched_get_priority_max(SCHED_FIFO);\n    status = sched_setscheduler(0, SCHED_FIFO, &sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n#endif\n\n    /* Create threads executing the Simulink model */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n#if MW_SP_SCHED_FIFO\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n#else\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n#endif\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* Set thread stack size if necessary */\n    status = pthread_attr_getstacksize(&attr, &stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_getstacksize\");\n    if (stackSize < STACK_SIZE) {\n        /* Make sure that stackSize is a multiple of 8 */\n        stackSize = (STACK_SIZE + 7) & (~0x7);\n        pthread_attr_setstacksize(&attr, stackSize);\n        CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n    }\n\n    signal(SIGTERM, exitFcn);     /* kill */\n    signal(SIGHUP, exitFcn);      /* kill -HUP */\n    signal(SIGINT, exitFcn);      /* Interrupt from keyboard */\n    signal(SIGQUIT, exitFcn);     /* Quit from keyboard */\n\n#ifdef MW_STANDALONE_EXECUTION_PROFILER_ON\n    status = pthread_mutex_init(&profilingDataStoreMutex, NULL);    \n#endif\n    \n#ifdef MW_HAS_MULTIPLE_RATES\n    MW_DEBUG_LOG(\"**creating subrate task threads**\\n\");   \n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"sem_init\");\n        setThreadPriority(subratePriority[i], &attr, &sp);\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void *)&taskId[i]);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n        /* Set name of sub-rate threads */\n        snprintf(thisTaskName, MW_MAX_TASKNAME, \"%s\", _mwTskMgrTimerDrivenTaskNames[i+1]);\n        MW_DEBUG_LOG(thisTaskName);   \n        status = pthread_setname_np(subRateThread[i], thisTaskName);\n        CHECK_STATUS(status, 0, \"pthread_setname_np at subRateThread\");\n#endif        \n#ifdef DETECT_OVERRUNS\n        status = pthread_mutex_init(&rateTaskFcnRunningMutex[i+1], NULL);\n        CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif        \n#ifdef COREAFFINITYREQUIRED\n        if (coreAffinity[i] >= 0) {\n             cpu_set_t cpuset;\n             CPU_ZERO(&cpuset);\n             CPU_SET(coreAffinity[i], &cpuset);\n             status = pthread_setaffinity_np(subRateThread[i], sizeof(cpu_set_t), &cpuset);\n             CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n         }\n#endif\n    }\n#endif\n\n    MW_DEBUG_LOG(\"**creating the base rate task thread**\\n\");    \n    setThreadPriority(MW_BASERATE_PRIORITY, &attr, &sp);  \n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the base-rate thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, _mwTskMgrTimerDrivenTaskNames[0]);\n    status = pthread_setname_np(baseRateThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at baserateThread\");\n#endif\n    \n#ifdef DETECT_OVERRUNS\n    status = pthread_mutex_init(&rateTaskFcnRunningMutex[0], NULL);\n    CHECK_STATUS(status, 0, \"pthread_mutex_init\");\n#endif\n\n#ifdef COREAFFINITYREQUIRED\n    if (coreAffinityBaseRate >= 0) {\n        cpu_set_t cpuset;\n        CPU_ZERO(&cpuset);\n        CPU_SET(coreAffinityBaseRate, &cpuset);\n        status = pthread_setaffinity_np(baseRateThread, sizeof(cpu_set_t), &cpuset);\n        CHECK_STATUS(status, 0, \"pthread_setaffinity_np\");\n    }   \n#endif\n\n#ifdef MW_SOC_ENABLED    \n    MW_DEBUG_LOG(\"**creating the socb base rate timer handler thread**\\n\");  \n    /* Set the priority higher (higher number) than the base rate */    \n    setThreadPriority(MW_BASERATE_PRIORITY + 2, &attr, &sp);\n    info.period = MW_BASERATE_PERIOD;\n    status = pthread_create(&baseTimerThread, &attr, &baseTimerTask, (void *) &info);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n    status = pthread_setname_np(baseTimerThread, \"baseTimerTask\");\n#endif \n    \n    MW_DEBUG_LOG(\"**creating the scheduler thread**\\n\");  \n    #ifdef MW_SCHEDULE_TASK_WITH_ALSA_AUDIO\n        status = pthread_create(&schedulerThread, &attr, &schedulerTaskALSA, (void *) &info);\n    #else\n        /* Set the priority higher (higher number) than the base rate */    \n        setThreadPriority(MW_BASERATE_PRIORITY + 1, &attr, &sp);\n        info.period = MW_BASERATE_PERIOD;\n        status = pthread_create(&schedulerThread, &attr, &schedulerTask, (void *) &info);\n    #endif\n    CHECK_STATUS(status, 0, \"pthread_create\");\n       \n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the scheduler thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"scheduler\");\n    status = pthread_setname_np(schedulerThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at scheduler thread\");\n#endif\n\n#ifdef MW_HAS_APERIODIC_TASKS\n    MW_DEBUG_LOG(\"**creating asynchronously triggered task threads**\\n\"); \n    /* Set the priority higher (higher number) than the base rate */    \n    sp.sched_priority = MW_BASERATE_PRIORITY + 1;\n    for (i = 0; i < MW_NUMBER_APERIODIC_TASKS; i++) {\n        status = pthread_create(&asyncThread[i], &attr, (void *) pAsyncTasks[i], NULL);\n        CHECK_STATUS(status, 0, \"pthread_create\");\n    }\n#endif\n    \n#ifdef MW_NEEDS_BACKGROUND_TASK\n    MW_DEBUG_LOG(\"**creating the background thread**\\n\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    setThreadPriority(0, &attr, &sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_create\");\n#ifdef MW_TSKMGR_TIMER_DRIVEN_TASKS\n    /* Set name of the background thread */\n    snprintf(thisTaskName, MW_MAX_TASKNAME, \"background\");\n    status = pthread_setname_np(backgroundThread, thisTaskName);\n    CHECK_STATUS(status, 0, \"pthread_setname_np at backgroundThread\");\n#endif \n#if MW_SP_SCHED_FIFO == 0\n    status = pthread_setschedparam(backgroundThread, SCHED_IDLE, &sp);\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#ifdef MW_HAS_COMM_SERVICE\n    status = makeCSTaskIdle();\n    CHECK_STATUS(status, 0, \"pthread_setschedparam\");\n#endif \n#endif\n#endif\n\n    pthread_attr_destroy(&attr);\n    fflush(stdout);\n}\n"},{"name":"owl.cpp","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\Custom_Library\\PhaseSpase_Cameras\\PHASESPACE\\src","tag":"","groupDisplay":"Other files","code":"/***\r\nCopyright (c) PhaseSpace, Inc 2016\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL PHASESPACE, INC\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n***/\r\n\r\n// owl.cc -*- C++ -*-\r\n// OWL C++ API v2.0\r\n// OW::Type, OWL::Variant, OWL::Event and OWL::ContextData implementations\r\n\r\n// Event queue notes:\r\n// Device::events are unhandled.\r\n// ContextData:: events and currentEvent are handled.\r\n// try to keep at most 1 event in handled event queue\r\n// in order to keep events and internal state in sync.\r\n// Context:: open() and initialize() are special cases,\r\n// and are allowed to hold multiple events in handled queue\r\n\r\n#include <iostream>\r\n#include <cstring>\r\n#include <stdexcept>\r\n\r\n#include \"libowl.h\"\r\n#include \"owl_math.h\"\r\n\r\nusing namespace std;\r\nusing namespace OWL;\r\n\r\n//// utils ////\r\n\r\nnamespace OWL {\r\n\r\n  template <typename T>\r\n  inline bool rescale(T *first, T *last, const std::vector<int> &tb_src, const std::vector<int> &tb_dst)\r\n  {\r\n    if(tb_src.size() != 2 || tb_dst.size() != 2) return false;\r\n    for(T *i = first; i != last; i++)\r\n      i->time = rescale(i->time, tb_src[0], tb_src[1], tb_dst[0], tb_dst[1]);\r\n    return first != last;\r\n  }\r\n\r\n  inline bool subsample(int64_t t, float systemfrequency, float frequency)\r\n  {\r\n    if(systemfrequency <= 0) return false;\r\n    if(frequency <= 0) return true;\r\n    int r = systemfrequency / frequency;\r\n    if(r <= 0) r = 1;\r\n    return (t % r);\r\n  }\r\n\r\n  extern Filter* create_filter(const strings &s);\r\n} // namespace OWL\r\n\r\n//// MarkerInfo ////\r\n\r\nMarkerInfo::MarkerInfo(uint32_t id, uint32_t tracker_id, const std::string &name, const std::string &options) :\r\n  id(id), tracker_id(tracker_id), name(name), options(options) { }\r\n\r\n//// TrackerInfo ////\r\n\r\nTrackerInfo::TrackerInfo(uint32_t id, const std::string &type, const std::string &name,\r\n\t\t\t const std::string &options, const std::vector<uint32_t> &marker_ids) :\r\n  id(id), type(type), name(name), options(options), marker_ids(marker_ids) { }\r\n\r\nTrackerInfo::TrackerInfo(uint32_t id, const std::string &type, const std::string &name,\r\n\t\t\t const std::string &options, const std::string &marker_ids) :\r\n  id(id), type(type), name(name), options(options) { get(marker_ids, this->marker_ids); }\r\n\r\n//// FilterInfo ////\r\n\r\nFilterInfo::FilterInfo(uint32_t period, const std::string &name, const std::string &options) :\r\n  period(period), name(name), options(options) { }\r\n\r\n//// DeviceInfo ////\r\n\r\nDeviceInfo::DeviceInfo(uint64_t hw_id, uint32_t id) : hw_id(hw_id), id(id), time(0) { }\r\n\r\n//// Type ////\r\n\r\nType::Type(uint32_t id, const void *data) : id(id), data(data) { }\r\n\r\n//// Variant ////\r\n\r\nVariant::Variant() : _id(0), _flags(0), _data(0), _data_end(0), _type_name(0) { }\r\n\r\nVariant::Variant(const Variant &v) :\r\n  _id(v._id), _flags(v._flags), _data(0), _data_end(0), _type_name(v._type_name)\r\n{ create(type_id(), &_data, &_data_end, v._data, v._data_end); }\r\n\r\nVariant::~Variant()\r\n{ destroy(type_id(), &_data, &_data_end); }\r\n\r\nVariant& Variant::operator=(const Variant &v)\r\n{\r\n  _id = v._id;\r\n  _flags = v._flags;\r\n  _type_name = v._type_name;\r\n  _data = 0;\r\n  _data_end = 0;\r\n  create(type_id(), &_data, &_data_end, v._data, v._data_end);\r\n  return *this;\r\n}\r\n\r\nuint16_t Variant::type_id() const { return _id & 0xFFFF; }\r\nuint32_t Variant::flags() const { return _flags; }\r\n\r\nconst char* Variant::type_name() const { return _type_name; }\r\n\r\nbool Variant::valid() const { return type_id(); }\r\nbool Variant::empty() const { return _data == _data_end; }\r\n\r\nconst Type Variant::begin() const { return Type(type_id(), _data); }\r\nconst Type Variant::end() const { return Type(type_id(), _data_end); }\r\n\r\nstd::string Variant::str() const\r\n{\r\n  switch(type_id())\r\n    {\r\n    case Type::INT: return ostring() << vector<int>((const int*)begin(), (const int*)end());\r\n    case Type::FLOAT: return ostring() << vector<float>((const float*)begin(), (const float*)end());\r\n    }\r\n  return std::string((const char*)begin(), (const char*)end());\r\n}\r\n\r\n//// Event ////\r\n\r\nEvent::Event() : Variant(), _name(0), _time(-1) { }\r\n\r\nuint16_t Event::type_id() const { return Variant::type_id(); }\r\nuint16_t Event::id() const { return _id >> 16; }\r\nuint32_t Event::flags() const { return _flags; }\r\nint64_t Event::time() const { return _time; }\r\n\r\nconst char* Event::type_name() const { return _type_name; }\r\nconst char* Event::name() const { return _name; }\r\n\r\nstd::string Event::str() const { return Variant::str(); }\r\n\r\nconst Event* Event::find(uint16_t type_id, const std::string &name) const\r\n{\r\n  if(type_id == 0 && name.empty()) return 0;\r\n  if(this->type_id() != Type::FRAME) return 0;\r\n  for(const Event *e = begin(); e != end(); e++)\r\n    if(e && (type_id == 0 || type_id == e->type_id()) && (name.empty() || name == e->name()))\r\n      return e;\r\n  return 0;\r\n}\r\n\r\nconst Event* Event::find(const std::string &name) const\r\n{ return find(0, name); }\r\n\r\n//// Frame ////\r\n\r\nFrame::Frame(int64_t time) :\r\n  time(time),\r\n  peaks(Type::PEAK, 0, 0, time),\r\n  planes(Type::PLANE, 0, 0, time),\r\n  markers(Type::MARKER, 0, 0, time),\r\n  rigids(Type::RIGID, 0, 0, time),\r\n  marker_vel(Type::FLOAT, 0, 0, time),\r\n  rigid_vel(Type::FLOAT, 0, 0, time)\r\n{\r\n}\r\n\r\nbool Frame::set(const Event &e)\r\n{\r\n  switch(e.type_id())\r\n    {\r\n    case Type::PEAK: peaks.set(e); return true;\r\n    case Type::PLANE: planes.set(e); return true;\r\n    case Type::MARKER: markers.set(e); return true;\r\n    case Type::RIGID: rigids.set(e); return true;\r\n    default: events.push_back(e); return true;\r\n    }\r\n  return false;\r\n}\r\n\r\nbool Frame::append(const Event &e)\r\n{\r\n  switch(e.type_id())\r\n    {\r\n    case Type::PEAK: peaks.append(e); return true;\r\n    case Type::PLANE: planes.append(e); return true;\r\n    case Type::MARKER: markers.append(e); return true;\r\n    case Type::RIGID: rigids.append(e); return true;\r\n    default: events.insert(events.end(), (const Event*)e.begin(), (const Event*)e.end()); return true;\r\n    }\r\n  return false;\r\n}\r\n\r\n#define VALID(d) d.id && !d.empty()\r\n#define EVENT(e) EventPrivate(e.type, e.id, e.flags, e.time, e)\r\n\r\nbool Frame::get(uint32_t id, EventPrivate &e)\r\n{\r\n  if(time == -1 || id == 0) return false;\r\n  vector<Event> frame;\r\n  if(VALID(peaks)) frame.push_back(EVENT(peaks));\r\n  if(VALID(planes)) frame.push_back(EVENT(planes));\r\n  if(VALID(markers)) frame.push_back(EVENT(markers));\r\n  if(VALID(rigids)) frame.push_back(EVENT(rigids));\r\n  if(VALID(marker_vel)) frame.push_back(EVENT(marker_vel));\r\n  if(VALID(rigid_vel)) frame.push_back(EVENT(rigid_vel));\r\n  if(!events.empty()) frame.insert(frame.end(), events.begin(), events.end());\r\n  e = EventPrivate(Type::FRAME, id, 0, time, frame);\r\n  return true;\r\n}\r\n\r\nbool Frame::get(uint32_t id, OWL::Events &e)\r\n{\r\n  if(time == -1 || id == 0) return false;\r\n  e.push_back(EventPrivate());\r\n  return get(id, e.back());\r\n}\r\n\r\n//// Frames ////\r\n\r\nFrames::Frames(uint32_t id, int64_t capacity) : id(id), capacity(capacity)\r\n{\r\n}\r\n\r\nbool Frames::push(const EventPrivate &frame)\r\n{\r\n  if(capacity <= 0) return false;\r\n\r\n  //if(frame.type_id() != Type::FRAME || frame.empty() == 0) return false;\r\n  if(frame.type_id() != Type::FRAME) return false;\r\n\r\n  push_back(Frame(frame.time()));\r\n\r\n  for(const Event *e = frame.begin<Event>(), *end = frame.end<Event>(); e != end; e++)\r\n    back().set(*e);\r\n\r\n  return true;\r\n}\r\n\r\nbool Frames::merge(const EventPrivate &frame)\r\n{\r\n  if(capacity <= 0) return false;\r\n\r\n  for(iterator f = begin(); f != end(); f++)\r\n    if(f->time == frame.time())\r\n      {\r\n        if(frame.type_id() == Type::FRAME)\r\n          for(const Event *e = frame.begin<Event>(), *end = frame.end<Event>(); e != end; e++)\r\n            f->append(*e);\r\n        else f->append(frame);\r\n        return true;\r\n      }\r\n  return false;\r\n}\r\n\r\nbool Frames::get(EventPrivate &frame, int64_t p)\r\n{\r\n  if(empty()) return false;\r\n\r\n  for(reverse_iterator f = rbegin(); f != rend(); f++)\r\n    {\r\n      int64_t dt = back().time - f->time;\r\n      if(dt < 0 || dt >= p) return f->get(id, frame);\r\n    }\r\n\r\n  return false;\r\n}\r\n\r\nbool Frames::pop(EventPrivate *frame)\r\n{\r\n  if(empty()) return false;\r\n\r\n  int64_t dt = back().time - front().time;\r\n  if(dt < 0 || dt >= capacity)\r\n    {\r\n      if(frame) front().get(id, *frame);\r\n      pop_front();\r\n      return true;\r\n    }\r\n\r\n  return false;\r\n}\r\n\r\n//// ContextBase ////\r\n\r\nContextBase::ContextBase(const std::string &name) : name(name), properties(types), enableEventMask(true)\r\n{\r\n}\r\n\r\nContextBase::~ContextBase()\r\n{\r\n}\r\n\r\nvoid ContextBase::clear()\r\n{\r\n  error.clear();\r\n  properties.clear();\r\n\r\n  properties.set(\"opened\", int(0));\r\n  properties.set(\"initialized\", int(0));\r\n  properties.set(\"streaming\", int(0));\r\n  properties.set(\"name\", string(\"\"));\r\n  properties.set(\"profile\", string(\"\"));\r\n  properties.set(\"local\", int(0));\r\n  properties.set(\"systemtimebase\", (int*)0, (int*)0);\r\n  properties.set(\"timebase\", (int*)0, (int*)0);\r\n  properties.set(\"maxfrequency\", (float)OWL_MAX_FREQUENCY);\r\n  properties.set(\"systemfrequency\", float(0));\r\n  properties.set(\"frequency\", float(0));\r\n  properties.set(\"scale\", float(1));\r\n  float p[7] = {0, 0, 0, 1, 0, 0, 0};\r\n  properties.set(\"systempose\", p, p+7);\r\n  properties.set(\"pose\", p, p+7);\r\n  properties.set(\"options\", string(\"\"));\r\n  properties.set(\"systemcameras\", (Camera*)0, (Camera*)0);\r\n  properties.set(\"cameras\", (Camera*)0, (Camera*)0);\r\n  properties.set(\"markers\", int(0));\r\n  properties.set(\"markerinfo\", (MarkerInfo*)0, (MarkerInfo*)0);\r\n  properties.set(\"trackers\", (int*)0, (int*)0);\r\n  properties.set(\"trackerinfo\", (TrackerInfo*)0, (TrackerInfo*)0);\r\n  properties.set(\"filters\", string(\"\"));\r\n  properties.set(\"filterinfo\", (FilterInfo*)0, (FilterInfo*)0);\r\n  properties.set(\"deviceinfo\", (DeviceInfo*)0, (DeviceInfo*)0);\r\n  properties.set(\"profiles\", string(\"\"));\r\n  properties.set(\"defaultprofile\", string(\"\"));\r\n  properties.set(\"profiles.json\", string(\"\"));\r\n\r\n  options.clear();\r\n\r\n  eventMask.clear();\r\n}\r\n\r\n// return changed enable options\r\n// used independent of enableEventMask value\r\nstd::string ContextBase::enable(const table<TypeInfo> &names, const std::string &options)\r\n{\r\n  string o, ret;\r\n  stringmap m(options);\r\n  for(size_t i = 0; i < names.size(); i++)\r\n    {\r\n      bool changed = false;\r\n      string n = string(\"event.\")+names[i].name;\r\n      if(i >= eventMask.size()) *eventMask.set(i) = !(names[i].flags & 1), changed = true;\r\n      if(names[i].flags & 1)\r\n        {\r\n          if(get(m, n, o)) *eventMask.set(i) = strtoi(o), changed = true;\r\n          this->options[n] = eventMask[i]?\"1\":\"0\";\r\n          if(changed) ret += n+\"=\"+(eventMask[i]?\"1\":\"0\")+\" \";\r\n        }\r\n    }\r\n  //cout << \"### \" << name << \" enable local=\" << property<int>(\"local\") << \" [\" << options << \"] \" << ret << endl;\r\n  return ret;\r\n}\r\n\r\nbool ContextBase::handle_all(EventPrivate &e)\r\n{\r\n  if(enableEventMask && !eventMask.empty() && eventMask[e.id()] == 0) return true;\r\n  if(property<int>(\"local\") == 0 || e.time() == -1) return false;\r\n\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  float systemfrequency = properties(\"systemfrequency\"), frequency = properties(\"frequency\");\r\n\r\n  bool ret = (e.type_id() == Type::FRAME && subsample(e.time(), systemfrequency, frequency));\r\n  if(tbs.size() == 2 && tbd.size() == 2) e.rescale(tbs[0], tbs[1], tbd[0], tbd[1]);\r\n\r\n  return ret;\r\n}\r\n\r\n// options name=value [name=value] ...\r\n// name=value[,value...]\r\nvoid ContextBase::handle_byte(EventPrivate &e)\r\n{\r\n  const string s = e;\r\n\r\n  if(strcmp(\"options\", e.name()) == 0)\r\n    {\r\n      //std::cout << \"# \" << name << \" event: char options: \" << s << std::endl;\r\n      stringmap m(s);\r\n      for(stringmap::iterator o = m.begin(); o != m.end(); o++)\r\n        options[o->first] = o->second;\r\n      properties.set(\"options\", join(options));\r\n    }\r\n  else if(strcmp(\"initialize\", e.name()) == 0)\r\n    {\r\n      //std::cout << \"# \" << name << \" event: char initialize: \" << s << std::endl;\r\n      stringmap m(s);\r\n      for(stringmap::iterator o = m.begin(); o != m.end(); o++)\r\n        properties.autoset(o->first, o->second);\r\n    }\r\n  else if(strcmp(\"done\", e.name()) == 0)\r\n    {\r\n      stringmap m(s);\r\n      for(stringmap::iterator o = m.begin(); o != m.end(); o++)\r\n        properties.autoset(o->first, o->second);\r\n    }\r\n}\r\n\r\nvoid ContextBase::handle_int(EventPrivate &e)\r\n{\r\n  if(strcmp(e.name(), \"streaming\") == 0)\r\n    {\r\n      vector<int> n;\r\n      if(e.get(n) == 1) properties.set(\"streaming\", n[0]);\r\n    }\r\n  else if(strcmp(e.name(), \"timebase\") == 0)\r\n    {\r\n      vector<int> n;\r\n      if(e.get(n) == 2) properties.set(\"timebase\", n);\r\n    }\r\n}\r\n\r\nvoid ContextBase::handle_float(EventPrivate &e)\r\n{\r\n  if(strcmp(e.name(), \"frequency\") == 0)\r\n    {\r\n      vector<float> f;\r\n      if(e.get(f) == 1) properties.set(\"frequency\", f[0]);\r\n    }\r\n  else if(strcmp(e.name(), \"scale\") == 0)\r\n    {\r\n      vector<float> s;\r\n      if(e.get(s) == 1) properties.set(\"scale\", s[0]);\r\n    }\r\n  else if(strcmp(e.name(), \"pose\") == 0)\r\n    {\r\n      vector<float> p;\r\n      if(e.get(p) == 7) properties.set(\"pose\", p);\r\n    }\r\n  else if(strcmp(e.name(), \"systempose\") == 0)\r\n    {\r\n      vector<float> p;\r\n      if(e.get(p) == 7) properties.set(\"systempose\", p);\r\n    }\r\n  else if(strcmp(e.name(), \"markervelocities\") == 0)\r\n    {\r\n      float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n      float t[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};\r\n      float scale = property<float>(\"scale\");\r\n      vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n      properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n      if(systempose.size() == 7 && localpose.size() == 7)\r\n        {\r\n          owl_mult_qq(&localpose[3], &systempose[3], pose+3); // accumulate\r\n          owl_convert_pm(pose, t); // convert\r\n        }\r\n\r\n      if((e.size<float>() % 3) == 0)\r\n        for(float *p = e.begin<float>(); p != e.end<float>(); p+=3)\r\n          {\r\n            float v[3];\r\n            owl_mult_v3s(p, scale, v); // scale\r\n            owl_mult_mv3_v3(t, v, p); // transform\r\n          }\r\n    }\r\n  else if(strcmp(e.name(), \"rigidvelocities\") == 0)\r\n    {\r\n      float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n      float t[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};\r\n      float scale = property<float>(\"scale\");\r\n      vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n      properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n      if(systempose.size() == 7 && localpose.size() == 7)\r\n        {\r\n          owl_mult_qq(&localpose[3], &systempose[3], pose+3); // accumulate\r\n          owl_convert_pm(pose, t); // convert\r\n        }\r\n\r\n      if((e.size<float>() % 6) == 0)\r\n        for(float *p = e.begin<float>(); p != e.end<float>(); p+=6)\r\n          {\r\n            float v[3];\r\n            owl_mult_v3s(p, scale, v); // scale\r\n            owl_mult_mv3_v3(t, v, p); // transform\r\n            // ignore rotational velocity\r\n          }\r\n    }\r\n}\r\n\r\nvoid ContextBase::handle_camera(EventPrivate &e)\r\n{\r\n  Camera *begin = e.begin<Camera>(), *end = e.end<Camera>();\r\n  properties.set(\"systemcameras\", begin, end);\r\n\r\n  if(property<int>(\"local\") == 1)\r\n    {\r\n      float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n      float scale = property<float>(\"scale\");\r\n      vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n      properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n      // pose = local * (system * scale)\r\n      if(systempose.size() == 7 && localpose.size() == 7)\r\n        owl_mult_pps(&localpose[0], &systempose[0], scale, pose); // scale and accumulate\r\n\r\n      for(Camera *c = begin; c != end; c++)\r\n        if(c->cond > 0)\r\n          {\r\n            // camera = pose * (camera * scale)\r\n            float p[7];\r\n            copy(c->pose, c->pose+7, p);\r\n            owl_mult_pps(&pose[0], p, scale, c->pose); // scale and transform\r\n          }\r\n    }\r\n\r\n  properties.set(\"cameras\", begin, end);\r\n}\r\n\r\nvoid ContextBase::handle_frame(EventPrivate &f)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  EventPrivate *begin = f.begin<EventPrivate>(), *end = f.end<EventPrivate>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n\r\n  list<void*> erase;\r\n  for(EventPrivate *e = begin; e != end; e++)\r\n    {\r\n      if(!eventMask.empty() && eventMask[e->id()] == 0) { erase.push_back(e); continue; }\r\n\r\n      if(e->time() != -1 && tbs.size() == 2 && tbd.size() == 2)\r\n        e->rescale(tbs[0], tbs[1], tbd[0], tbd[1]);\r\n\r\n      switch(e->type_id())\r\n        {\r\n        case Type::BYTE: handle_byte(*e); break;\r\n        case Type::INT: handle_int(*e); break;\r\n        case Type::FLOAT: handle_float(*e); break;\r\n        case Type::FRAME: handle_frame(*e); break;\r\n        case Type::PEAK: handle_peak(*e); break;\r\n        case Type::PLANE: handle_plane(*e); break;\r\n        case Type::MARKER: handle_marker(*e); break;\r\n        case Type::RIGID: handle_rigid(*e); break;\r\n        case Type::INPUT: handle_input(*e); break;\r\n        }\r\n    }\r\n  if(!erase.empty()) f.erase<Event>(erase);\r\n}\r\n\r\nvoid ContextBase::handle_peak(EventPrivate &e)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  Peak *begin = e.begin<Peak>(), *end = e.end<Peak>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  rescale(begin, end, tbs, tbd);\r\n}\r\n\r\nvoid ContextBase::handle_plane(EventPrivate &e)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  Plane *begin = e.begin<Plane>(), *end = e.end<Plane>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  rescale(begin, end, tbs, tbd);\r\n\r\n  float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n  float t[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};\r\n  float scale = property<float>(\"scale\");\r\n  vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n  properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n  if(systempose.size() == 7 && localpose.size() == 7)\r\n    {\r\n      owl_mult_pps(&localpose[0], &systempose[0], scale, pose); // scale and accumulate\r\n      owl_convert_pm(pose, t); // convert\r\n    }\r\n\r\n  float pl[4] = {0,0,0,0};\r\n  for(Plane *p = begin; p != end; p++)\r\n    {\r\n      std::copy(p->plane, p->plane+4, pl);\r\n      pl[3] *= scale; // scale\r\n      owl_mult_mpl_pl(t, pl, p->plane); // transform\r\n      p->offset *= scale; // scale\r\n    }\r\n}\r\n\r\nvoid ContextBase::handle_marker(EventPrivate &e)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  Marker *begin = e.begin<Marker>(), *end = e.end<Marker>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  rescale(begin, end, tbs, tbd);\r\n\r\n  float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n  float t[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};\r\n  float scale = property<float>(\"scale\");\r\n  vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n  properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n  if(systempose.size() == 7 && localpose.size() == 7)\r\n    {\r\n      owl_mult_pps(&localpose[0], &systempose[0], scale, pose); // scale and accumulate\r\n      owl_convert_pm(pose, t); // convert\r\n    }\r\n\r\n  for(Marker *m = begin; m != end; m++)\r\n    if(m->cond > 0)\r\n      {\r\n        float v[3];\r\n        owl_mult_v3s(&m->x, scale, v); // scale\r\n        owl_mult_mv3_v3(t, v, &m->x); // transform\r\n      }\r\n}\r\n\r\nvoid ContextBase::handle_rigid(EventPrivate &e)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  Rigid *begin = e.begin<Rigid>(), *end = e.end<Rigid>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  rescale(begin, end, tbs, tbd);\r\n\r\n  float pose[7] = {0, 0, 0, 1, 0, 0, 0};\r\n  float scale = property<float>(\"scale\");\r\n  vector<float> systempose(pose, pose+7), localpose(pose, pose+7);\r\n  properties.get(\"systempose\", systempose); properties.get(\"pose\", localpose);\r\n\r\n  if(systempose.size() == 7 && localpose.size() == 7)\r\n    owl_mult_pps(&localpose[0], &systempose[0], scale, pose); // scale and accumulate\r\n\r\n  for(Rigid *r = begin; r != end; r++)\r\n    if(r->cond > 0)\r\n      {\r\n        float p[7];\r\n        copy(r->pose, r->pose+7, p);\r\n        owl_mult_pps(pose, p, scale, r->pose); // scale and transform\r\n      }\r\n}\r\n\r\nvoid ContextBase::handle_input(EventPrivate &e)\r\n{\r\n  if(property<int>(\"local\") == 0) return;\r\n\r\n  Input *begin = e.begin<Input>(), *end = e.end<Input>();\r\n  vector<int> tbs = properties(\"systemtimebase\"), tbd = properties(\"timebase\");\r\n  rescale(begin, end, tbs, tbd);\r\n}\r\n\r\n//// ContextData ////\r\n\r\nContextData::ContextData(Device *dev, const std::string &name) : ContextBase(name), dev(dev), internal(false)\r\n{\r\n  properties.set(\"maxfrequency\", (float)OWL_MAX_FREQUENCY);\r\n}\r\n\r\nContextData::~ContextData()\r\n{\r\n  close();\r\n  MutexLocker l(&deviceMutex);\r\n  delete dev;\r\n  dev = 0;\r\n}\r\n\r\nint ContextData::open(const std::string &device, const std::string &device_options)\r\n{\r\n  MutexLocker l(&deviceMutex);\r\n  if(!dev) { error = \"fatal: invalid device\"; return -1; }\r\n  int ret = dev->open(device, device_options);\r\n  if(ret < 0) error = dev->error;\r\n  return ret;\r\n}\r\n\r\nbool ContextData::close()\r\n{\r\n  MutexLocker l(&deviceMutex);\r\n  if(dev) dev->close();\r\n\r\n  error.clear();\r\n\r\n  properties.clear();\r\n  properties.set(\"maxfrequency\", (float)OWL_MAX_FREQUENCY);\r\n\r\n  options.clear();\r\n\r\n  eventMask.clear();\r\n\r\n  markers.clear();\r\n  trackers.clear();\r\n  devices.clear();\r\n  filters.clear();\r\n\r\n  events.clear();\r\n  currentEvent = Event();\r\n\r\n  names.clear();\r\n  types.clear();\r\n\r\n  return true;\r\n}\r\n\r\nbool ContextData::isOpen()\r\n{ MutexLocker l(&deviceMutex); return dev ? dev->is_open() : false; }\r\n\r\nvoid ContextData::clear()\r\n{\r\n  ContextBase::clear();\r\n\r\n  MutexLocker l(&deviceMutex);\r\n  if(dev) dev->events.clear();\r\n\r\n  events.clear();\r\n  currentEvent = Event();\r\n\r\n  markers.clear();\r\n  trackers.clear();\r\n  devices.clear();\r\n  filters.clear();\r\n}\r\n\r\nstd::string ContextData::enable(const std::string &options)\r\n{\r\n  if(enableEventMask && property<int>(\"local\") == 0) return string();\r\n  string ret = ContextBase::enable(names, options);\r\n  if(!ret.empty() && enableEventMask)\r\n    {\r\n      MutexLocker l(&deviceMutex);\r\n      int64_t time = dev ? dev->time : -1;\r\n      l.unlock();\r\n      EventPrivate e(Type::BYTE, \"options\", 0, time, ret);\r\n      new_event(e);\r\n    }\r\n  return ret;\r\n}\r\n\r\nEventPrivate* ContextData::peekEvent(long timeout)\r\n{\r\n  if(events.empty()) recv(timeout);\r\n  return !events.empty() ? &events.front() : 0;\r\n}\r\n\r\nEventPrivate* ContextData::nextEvent(long timeout)\r\n{\r\n  if(events.empty()) recv(timeout);\r\n  if(events.empty()) return 0;\r\n\r\n  //currentEvent = events.front();\r\n  currentEvent.swap(events.front());\r\n  events.pop_front();\r\n\r\n  return &currentEvent;\r\n}\r\n\r\n// messages //\r\n\r\nint ContextData::recv(long timeout)\r\n{\r\n  MutexLocker l(&deviceMutex);\r\n  if(!dev) { error = \"fatal: invalid device\"; return -1; }\r\n  int ret = dev->read(dev->events.empty() ? timeout : 0);\r\n  if(ret < 0) error = dev->error;\r\n  // try to have at least one event in handled events buffer\r\n  do {\r\n    if(!dev->events.empty())\r\n      {\r\n        new_event(dev->events.front());\r\n        dev->events.pop_front();\r\n      }\r\n  } while(!dev->events.empty() && events.empty());\r\n  return ret;\r\n}\r\n\r\nint ContextData::send(uint16_t type, uint16_t id, uint32_t flags, const char *data, size_t size)\r\n{\r\n  MutexLocker l(&deviceMutex);\r\n  if(!dev) { error = \"fatal: invalid device\"; return -1; }\r\n  if(!valid(id)) { error = ostring() << \"error: invalid command id: \" << id; return -1; }\r\n  uint32_t mode = property<int>(\"slave\");\r\n  if(mode && mode < names[id].mode) { error = \"error: permission denied\"; return -1; }\r\n  int ret = 0;\r\n  if(ret <= 0)\r\n    {\r\n      ret = dev->write(type, id, flags, data, size);\r\n      if(ret < 0) error = dev->error;\r\n    }\r\n  return ret;\r\n}\r\n\r\nbool ContextData::send(const std::string &name, const std::string &s)\r\n{ return send(Type::BYTE, names[name], 0, s.data(), s.size()) > 0; }\r\n\r\nbool ContextData::send(const std::string &name, const std::vector<int> &v)\r\n{ return send(Type::INT, names[name], 0, (const char*)v.data(), v.size() * sizeof(int)) > 0; }\r\n\r\nbool ContextData::send(const std::string &name, const std::vector<float> &v)\r\n{ return send(Type::FLOAT, names[name], 0, (const char*)v.data(), v.size() * sizeof(float)) > 0; }\r\n\r\n// FilterGroup::options(): type=type [options] [type=type] ...\r\nstd::string FilterGroup::options() const\r\n{\r\n  ostring out;\r\n  for(const_iterator i = begin(); i != end(); i++)\r\n    if(Filter *f = *i)\r\n      out << (i==begin()?\"\":\" \") << \"type=\" << f->type << (f->options.empty()?\"\":\" \") << f->options;\r\n  return out;\r\n}\r\n\r\n// filter=name period=n type=type [options] [type=type] ... [filter=name] ...\r\nFilters ContextData::filter(const std::string &options, bool enable)\r\n{\r\n  // filters can exist independent of local\r\n\r\n  vector<FilterInfo> fi;\r\n  strings opts = split(options, ' ');\r\n  for(size_t i = 0; i < opts.size(); i++)\r\n    {\r\n      strings o = split(opts[i], '=');\r\n      if(o.size() != 2) { error = \"filter: invalid option: \" + opts[i]; return Filters(); }\r\n\r\n      if(o[0] == \"filter\")\r\n        {\r\n          string name = o[1];\r\n          if(name.empty()) { error = \"filter: empty name\"; return Filters(); }\r\n          uint32_t id = names[name];\r\n          if(valid(id) && !(names[id].flags & 2))\r\n            { error = \"filter: invalid name: \" + name; return Filters(); }\r\n          fi.push_back(FilterInfo(0, name));\r\n        }\r\n      else if(fi.empty())\r\n        { error = \"filter: no filter\"; return Filters(); }\r\n      else if(o[0] == \"period\")\r\n        {\r\n          int32_t p = strtoll(o[1]);\r\n          if(p < 0) { error = \"filter: invalid period: \" + o[1]; return Filters(); }\r\n          fi.back().period = p;\r\n        }\r\n      else fi.back().options += (fi.back().options.empty()?\"\":\" \") + opts[i];\r\n    }\r\n\r\n  return filter(fi.data(), fi.data()+fi.size(), enable);\r\n}\r\n\r\n// FilterInfo::options: type=type [options] [type=type] ...\r\nFilters ContextData::filter(const FilterInfo *first, const FilterInfo *last, bool enable)\r\n{\r\n  if(!first || !last || first == last) return Filters();\r\n\r\n  int local = property<int>(\"local\");\r\n  error.clear();\r\n  Filters new_filters(true), changed_filters(true); // shared\r\n  for(const FilterInfo *i = first; i != last; i++)\r\n    {\r\n      uint32_t id = names[i->name];\r\n      if(i->name.empty()) { error = \"filter: empty name\"; break; }\r\n      if(valid(id) && !(names[id].flags & 2))\r\n        { error = \"filter: invalid name: \" + i->name; break; }\r\n      if(!valid(id)) send(\"internal\", \"name=\" + i->name);\r\n      FilterGroup *g = filters.find(i->name);\r\n      if(local == 1 && !enable && g && g->enabled) continue; // keep local filter\r\n      if(!g) g = new_filters.find(i->name);\r\n      if(g) { g->clear(); g->setPeriod(i->period); changed_filters.push_back(g); }\r\n      else new_filters.push_back(g = new FilterGroup(id, i->name, i->period));\r\n\r\n      if(i->options.empty()) continue;\r\n\r\n      Filter *f = 0;\r\n      strings opts = split(i->options, ' ');\r\n      for(size_t i = 0; i < opts.size(); i++)\r\n        {\r\n          strings o = split(opts[i], '=');\r\n          if(o.size() != 2) { error = \"filter: invalid option: \" + opts[i]; break; }\r\n\r\n          if(o[0] == \"type\")\r\n            {\r\n              strings s = split(o[1], ',');\r\n              if(s.empty()) { error = \"filter: no type\"; break; }\r\n              f = create_filter(s);\r\n              if(!f) { error = \"filter: invalid type: \" + s[0]; break; }\r\n              g->push_back(f);\r\n            }\r\n          else if(!f)\r\n            { error = \"filter: no filter\"; break; }\r\n          else if(!f->set(o))\r\n            { error = \"filter: set options failed: \" + opts[i]; break; }\r\n        }\r\n      g->enabled = true;\r\n    }\r\n\r\n  if(!error.empty() || (new_filters.empty() && changed_filters.empty())) { new_filters.clear(); return Filters(); }\r\n\r\n  new_filters.enabled = true; // success\r\n  for(Filters::iterator i = new_filters.begin(); i != new_filters.end(); i++)\r\n    if(FilterGroup *g = *i)\r\n      filters.push_back(g), changed_filters.push_back(g);\r\n\r\n  string changed;\r\n  for(Filters::iterator i = changed_filters.begin(); i != changed_filters.end(); i++)\r\n    if(FilterGroup *g = *i)\r\n      changed += \"event.\"+g->name+\"=\"+(g->enabled?\"1\":\"0\");\r\n\r\n  filters.enabled = false;\r\n  if(enable)\r\n    for(Filters::iterator i = filters.begin(); i != filters.end(); i++)\r\n      if(FilterGroup *g = *i)\r\n        if(g->enabled) filters.enabled = true;\r\n\r\n  ContextData::enable(changed);\r\n\r\n  MutexLocker l(&deviceMutex);\r\n  int64_t time = dev ? dev->time : -1;\r\n  l.unlock();\r\n  update_filter_info(time);\r\n\r\n  return changed_filters;\r\n}\r\n\r\nconst FilterInfo ContextData::filterInfo(const std::string &name)\r\n{\r\n  FilterGroup *g = filters.find(name);\r\n  if(!g) return FilterInfo();\r\n\r\n  return FilterInfo(g->period, g->name, g->options());\r\n}\r\n\r\n/// events ///\r\n\r\nint ContextData::new_event(EventPrivate &e, bool flag)\r\n{\r\n  // lazy name event\r\n  if(e.id() == 0xffff && e.name())\r\n    {\r\n      // lookup actual id by lazy name\r\n      uint16_t id = names[e.name()];\r\n      if(!valid(id))\r\n        {\r\n          cerr << \"warning: unknown event: type=\" << e.type_id() << \" name=\" << e.name() << endl;\r\n          return 1;\r\n        }\r\n      e._id = (e._id & 0x0000ffff) | (id << 16);\r\n    }\r\n\r\n  // unknown event\r\n  if(e.id() != 0 && (e.type_id() >= types.size() || e.id() >= names.size()))\r\n    {\r\n      cerr << \"warning: unknown event: type=\" << e.type_id() << \" id=\" << e.id() << endl;\r\n      return 1;\r\n    }\r\n\r\n  if(e.id() != 0 && e.time() != -1 && property<int>(\"initialized\") == 0)\r\n    {\r\n      //cout << \"# drop event: type=\" << e.type_id() << \" id=\" << e.id() << \" time=\" << e.time() << endl;\r\n      return 1;\r\n    }\r\n\r\n  e._type_name = types[e.type_id()].name;\r\n  e._flags = names[e.id()].flags;\r\n  e._name = names[e.id()].name;\r\n\r\n  //cout << \"# \" << name << \" new event: t=\" << e.time() << \" \" << (e.type_name()?e.type_name():\"\") << \" \" << (e.name()?e.name():\"\") << endl;\r\n\r\n  if(e.type_id() == Type::FRAME)\r\n    for(Event *i = e.begin<Event>(); i != e.end<Event>(); i++)\r\n      if(i->type_id() && i->type_id() < types.size() && i->id())\r\n        {\r\n          if(i->id() == 0xffff && i->name()) // lazy name event\r\n            {\r\n              uint16_t id = names[i->name()];\r\n              if(valid(id)) i->_id = (i->_id & 0x0000ffff) | (id << 16);\r\n              else cerr << \"warning: unknown event: type=\" << e.type_id() << \" name=\" << e.name() << endl;\r\n            }\r\n          if(i->id() < names.size())\r\n            {\r\n              i->_type_name = types[i->type_id()].name;\r\n              i->_flags = names[i->id()].flags;\r\n              i->_name = names[i->id()].name;\r\n            }\r\n          else cerr << \"warning: unknown event: type=\" << e.type_id() << \" id=\" << e.id() << endl;\r\n        }\r\n\r\n  // handle internal event\r\n  if(e.id() == 0)\r\n    {\r\n      return handle_internal(e);\r\n    }\r\n\r\n  // filter is applied only to \"raw\" frames\r\n  bool filter = (flag && filters.enabled && e.type_id() == Type::FRAME && strcmp(\"raw\", e.name()) == 0);\r\n\r\n  // filter push and apply\r\n  if(filter) filters.push(e);\r\n\r\n  // merge event into filters\r\n  if(flag && filters.enabled && (e.flags() & 0x80)) filters.merge(e);\r\n\r\n  int ret = e.valid();\r\n  if(!handle_all(e))\r\n    {\r\n      switch(e.type_id())\r\n        {\r\n        case Type::BYTE: handle_byte(e); break;\r\n        case Type::INT: handle_int(e); break;\r\n        case Type::FLOAT: handle_float(e); break;\r\n        case Type::FRAME: handle_frame(e); break;\r\n        case Type::CAMERA: handle_camera(e); break;\r\n        case Type::PEAK: handle_peak(e); break;\r\n        case Type::PLANE: handle_plane(e); break;\r\n        case Type::MARKER: handle_marker(e); break;\r\n        case Type::RIGID: handle_rigid(e); break;\r\n        case Type::INPUT: handle_input(e); break;\r\n        }\r\n\r\n      //events.push_back(e);\r\n      events.push_back(EventPrivate());\r\n      events.back().swap(e);\r\n    }\r\n\r\n  // filter pop\r\n  if(filter)\r\n    {\r\n      for(Filters::iterator i = filters.begin(); i != filters.end(); i++)\r\n        if(FilterGroup *g = *i)\r\n          {\r\n            if(g->out.capacity <= 0) continue;\r\n\r\n            EventPrivate frame;\r\n            if(g->pop(frame)) new_event(frame, false);\r\n          }\r\n    }\r\n\r\n  return ret;\r\n}\r\n\r\n// protected //\r\n\r\n// table=name num=name[,flags]\r\n// table=types 0=void 1=char 2=int 3=float 127=error 128=Camera 129=Marker 130=Rigid\r\n// table=names 0=internal 1=warning 2=error 3=fatal ...\r\n// table=enable name=value\r\n// table=trackers id=tid,tid,type,name [options ...]\r\n// table=markers id=mid,tid,type,name [options ...]\r\n// table=devices id=hwid,id,type,name [options ...]\r\n// status=devices id=hwid,time [status ...]\r\n// property=value\r\nint ContextData::handle_internal(EventPrivate &e)\r\n{\r\n  string s = e;\r\n  if(s.empty()) return 0;\r\n\r\n  //cout << \"# \" << name << \" event: t=\" << e.time() << \" char internal: \" << s << endl;\r\n\r\n  if(internal)\r\n    {\r\n      // keep internal events\r\n      events.push_back(e);\r\n    }\r\n\r\n  if(s.find(\"table=\") == 0)\r\n    {\r\n      if(types.parse(\"types\", s));\r\n      else if(names.parse(\"names\", s))\r\n        {\r\n          // update filters\r\n          string changed;\r\n          for(Filters::iterator i = filters.begin(); i != filters.end(); i++)\r\n            if(FilterGroup *g = *i)\r\n              if(!valid(g->in.id) || !valid(g->out.id))\r\n                {\r\n                  g->in.id = g->out.id = names[g->name];\r\n                  changed += \"event.\"+g->name+\"=\"+(g->enabled?\"1\":\"0\");\r\n                  //cout << \"# filtergroup \" << name << \" name=\" << g->name << \" id=\" << names[g->name] << endl;\r\n                }\r\n\r\n          string ret = enable(changed);\r\n          if(!enableEventMask && !ret.empty() && property<int>(\"initialized\") == 1)\r\n            {\r\n              EventPrivate e2(Type::BYTE, \"internal\", 0, e.time(), \"table=enable \"+ret);\r\n              new_event(e2);\r\n            }\r\n\r\n          if(!changed.empty()) update_filter_info(e.time());\r\n        }\r\n      else if(s.find(\"table=enable \") == 0)\r\n        {\r\n          if(enableEventMask) enable(s.substr(strlen(\"table=enable \")));;\r\n        }\r\n      else if(trackers.parse(\"trackers\", s))\r\n        {\r\n          vector<int> t;\r\n          vector<TrackerInfo> ti;\r\n          for(size_t i = 0; i < trackers.size(); i++)\r\n            {\r\n              if(trackers[i].id != (uint32_t)-1) t.push_back(i);\r\n              ti.push_back(trackers[i]);\r\n            }\r\n          properties.set(\"trackers\", t);\r\n          properties.set(\"trackerinfo\", ti);\r\n\r\n          {\r\n            EventPrivate e2(Type::TRACKERINFO, \"info\", 0, e.time(), ti);\r\n            new_event(e2);\r\n          }\r\n        }\r\n      else if(markers.parse(\"markers\", s))\r\n        {\r\n          for(size_t i = 0; i < trackers.size(); i++)\r\n            trackers.at(i)->marker_ids.clear();\r\n          vector<MarkerInfo> mi;\r\n          for(size_t i = 0; i < markers.size(); i++)\r\n            {\r\n              mi.push_back(markers[i]);\r\n              TrackerInfo *t = trackers.at(markers[i].tracker_id);\r\n              if(t) t->marker_ids.push_back(i);\r\n            }\r\n          vector<TrackerInfo> ti;\r\n          for(size_t i = 0; i < trackers.size(); i++)\r\n            ti.push_back(trackers[i]);\r\n          properties.set(\"markers\", (int)markers.size());\r\n          properties.set(\"markerinfo\", mi);\r\n          properties.set(\"trackerinfo\", ti);\r\n\r\n          {\r\n            EventPrivate e2(Type::MARKERINFO, \"info\", 0, e.time(), markers);\r\n            new_event(e2);\r\n            EventPrivate e3(Type::TRACKERINFO, \"info\", 0, e.time(), ti);\r\n            new_event(e3);\r\n          }\r\n        }\r\n      else if(devices.parse(\"devices\", s))\r\n        {\r\n          vector<DeviceInfo> di; di.reserve(devices.size());\r\n          for(idmap<DeviceInfo>::iterator i = devices.begin(); i != devices.end(); i++)\r\n            di.push_back(i->second);\r\n          properties.set(\"deviceinfo\", di);\r\n\r\n          {\r\n            EventPrivate e2(Type::DEVICEINFO, \"info\", 0, e.time(), di);\r\n            new_event(e2);\r\n          }\r\n        }\r\n    }\r\n  else if(s.find(\"status=\") == 0)\r\n    {\r\n      if(devices.parse(\"devices\", s))\r\n        {\r\n          vector<DeviceInfo> di; di.reserve(devices.size());\r\n          for(idmap<DeviceInfo>::iterator i = devices.begin(); i != devices.end(); i++)\r\n            di.push_back(i->second);\r\n\r\n          properties.set(\"deviceinfo\", di);\r\n\r\n          {\r\n            EventPrivate e2(Type::DEVICEINFO, \"info\", 0, e.time(), di);\r\n            new_event(e2);\r\n          }\r\n        }\r\n    }\r\n  else if(s.find(\"filter=\") == 0)\r\n    {\r\n      if(!filter(s, false) && !error.empty())\r\n        {\r\n          EventPrivate e2(Type::ERROR, \"warning\", 0, e.time(), error);\r\n          new_event(e2);\r\n        }\r\n    }\r\n  else\r\n    {\r\n      stringmap m(s);\r\n      for(stringmap::iterator o = m.begin(); o != m.end(); o++)\r\n        properties.autoset(o->first, o->second);\r\n    }\r\n\r\n  return 1;\r\n}\r\n\r\nvoid ContextData::update_filter_info(int64_t time)\r\n{\r\n  string fn;\r\n  vector<FilterInfo> fi;\r\n  for(Filters::iterator i = filters.begin(); i != filters.end(); i++)\r\n    if(FilterGroup *g = *i)\r\n      if(valid(g->in.id) && valid(g->out.id) && !g->options().empty())\r\n        {\r\n          fn += (fn.empty()?\"\":\",\") + g->name;\r\n          fi.push_back(FilterInfo(g->period, g->name, g->options()));\r\n        }\r\n\r\n  properties.set(\"filters\", fn);\r\n  properties.set(\"filterinfo\", fi);\r\n\r\n  {\r\n    EventPrivate e(Type::FILTERINFO, \"info\", 0, time, fi);\r\n    new_event(e);\r\n  }\r\n}\r\n\r\n////\r\n"},{"name":"owl_rpd.cpp","type":"source","group":"legacy","path":"C:\\Users\\SPOT\\Documents\\GitHub\\AlexCrain-SPOT\\Useful_Code\\CollectPhaseSpaceData\\CollectPhaseSpaceDataJetson_ert_rtw\\..\\..\\..\\Custom_Library\\PhaseSpase_Cameras\\PHASESPACE\\src","tag":"","groupDisplay":"Other files","code":"/***\r\nCopyright (c) PhaseSpace, Inc 2016\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL PHASESPACE, INC\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n***/\r\n\r\n// owl_rpd.cc\r\n// OWL C++ API v2.0\r\n\r\n#include <iostream>\r\n#include <vector>\r\n\r\n#include <stdio.h>\r\n#include <fcntl.h>\r\n#ifndef _MSC_VER\r\n#include <string.h>\r\n#include <unistd.h>\r\n#else\r\n#include <string>\r\n#include <io.h>\r\n#include <stdlib.h>\r\n#endif\r\n#include <errno.h>\r\n\r\n#include \"socket.h\"\r\n#include \"owl_rpd.hpp\"\r\n\r\nusing namespace std;\r\nusing namespace OWL;\r\n\r\n//// globals ////\r\n\r\nOWLAPI size_t _tcp_sndbuf_size = 0x400000;\r\nOWLAPI size_t _tcp_rcvbuf_size = 0x400000;\r\nOWLAPI size_t _rpd_chunk_size = 0x10000;\r\nOWLAPI size_t _tcp_connect_timeout = 5000000;\r\n\r\n//// RPD ////\r\n\r\nRPD::RPD() : fd(-1), sock(-1), mode(0),  _write(0), _read(0), _send(0), _recv(0)\r\n{ WINSOCK_INIT(); }\r\n\r\nRPD::~RPD()\r\n{\r\n  WINSOCK_DONE();\r\n  close();\r\n}\r\n\r\nint RPD::open(const char *servername, const char *filename, int mode)\r\n{\r\n  close();\r\n\r\n#ifdef WIN32\r\n  int flags = O_BINARY;\r\n#else\r\n  int flags = O_LARGEFILE;\r\n#endif\r\n\r\n  if(mode == RPD::SAVE)\r\n    fd = ::open(filename, O_WRONLY|O_CREAT|O_TRUNC|flags, 0644);\r\n  else if(mode == RPD::LOAD)\r\n    fd = ::open(filename, O_RDONLY|flags);\r\n  else\r\n    {\r\n      cerr << \"error: RPD::open: invalid mode \" << mode << endl;\r\n      return -1;\r\n    }\r\n\r\n  if(fd < 0)\r\n    {\r\n      cerr << \"error: RPD::open: could not open file \" << filename << \": \" << strerror(errno) << endl;\r\n      return -2;\r\n    }\r\n\r\n  this->mode = mode;\r\n\r\n  nonexec(fd);\r\n\r\n  // separate server name into name:port\r\n  char name[1024] = \"localhost\";\r\n  int port = 0;\r\n  if(servername) sscanf(servername, \"%[^:]:%d\", name, &port);\r\n\r\n  tcp_socket sock;\r\n  this->sock = sock.connect(name, 9000+port, 4*1000000);\r\n  if(this->sock < 0)\r\n    {\r\n      cerr << \"error: RPD::open: could not connect to \" << servername << endl;\r\n      return -3;\r\n    }\r\n\r\n  sock.nonblock();\r\n  sock.recv_bufsize(_tcp_rcvbuf_size);\r\n\r\n  std::string address = sock.getoaddr()?sock.getoaddr():\"\";\r\n  if(!address.empty()) cout << \"RPD: connect: \" << address << \" (\" << sock.sock() << \")\" << endl;\r\n\r\n  int ret = sock.send((char*)&mode, sizeof(mode));\r\n  if(ret != sizeof(mode))\r\n    {\r\n      cerr << \"error: RPD::open: send mode failed\" << endl;\r\n      sock.close(); this->sock = sock.sock();\r\n      return -4;\r\n    }\r\n\r\n  if(mode == RPD::LOAD)\r\n    {\r\n      cout << \"RPD: sending header\" << endl;\r\n      // retry send\r\n      for(int i = 0, count = 0; count < 0x100000 && i < 1000; i++)\r\n        {\r\n          ret = send(1000);\r\n          if(ret < 0) break;\r\n          if(ret > 0) count += ret;\r\n        }\r\n      if(ret < 0) { sock.close(); this->sock = sock.sock(); return ret; }\r\n    }\r\n\r\n  cout << \"RPD: opened: mode=\" << (mode==RPD::SAVE?\"save\":\"load\") << endl;\r\n\r\n  return 1;\r\n}\r\n\r\nbool RPD::close()\r\n{\r\n  if(fd > -1) ::close(fd);\r\n  fd = -1;\r\n  mode = 0;\r\n\r\n  tcp_socket sock(this->sock);\r\n  if(sock) cout << \"RPD: close (\" << sock.sock() << \")\" << endl;\r\n  sock.close(); this->sock = sock.sock();\r\n\r\n  if(_write || _read || _send || _recv)\r\n    cout << \"RPD: write=\" << _write << \" read=\" << _read << \" send=\" << _send << \" recv=\" << _recv << endl;\r\n\r\n  _write = _read = _send = _recv = 0;\r\n  return true;\r\n}\r\n\r\nbool RPD::flush()\r\n{\r\n  if(sock == -1 || mode != RPD::SAVE) return false;\r\n  while(sock != -1 && mode == RPD::SAVE && recv() > 0);\r\n  return true;\r\n}\r\n\r\nbool RPD::done()\r\n{\r\n  tcp_socket sock(this->sock);\r\n  if(!sock || mode != RPD::SAVE) return false;\r\n\r\n  // set mode=0\r\n  int mode = 0;\r\n  int ret = sock.send((char*)&mode, sizeof(mode));\r\n  if(ret != sizeof(mode))\r\n    {\r\n      cerr << \"error: RPD: done: send failed\" << endl;\r\n      this->sock = sock.sock();\r\n      return false;\r\n    }\r\n  return true;\r\n}\r\n\r\nint RPD::recv(long timeout)\r\n{\r\n  tcp_socket sock(this->sock);\r\n  if(!sock || mode != RPD::SAVE) return -1;\r\n\r\n  int ret = sock.select(timeout, 1);\r\n  if(ret <= 0) { this->sock = sock.sock(); return ret; }\r\n\r\n  buffer.resize(_rpd_chunk_size ? _rpd_chunk_size : 0x10000);\r\n\r\n  ret = sock.recv(buffer.data(), buffer.size());\r\n  if(ret <= 0) { this->sock = sock.sock(); return ret; }\r\n  _recv += ret;\r\n\r\n  int size = ret;\r\n\r\n  ret = write(fd, buffer.data(), size);\r\n  if(ret < 0) return ret;\r\n\r\n  // write exactly size bytes\r\n  if(ret != size)\r\n    {\r\n      cerr << \"error: RPD::write: failed to write \" << size << \" bytes\" << endl;\r\n      return -1;\r\n    }\r\n  _write += ret;\r\n\r\n  return ret;\r\n}\r\n\r\nint RPD::send(long timeout)\r\n{\r\n  tcp_socket sock(this->sock);\r\n  if(!sock || mode != RPD::LOAD) return -1;\r\n\r\n  int ret = sock.select(timeout, 2);\r\n  if(ret <= 0) { this->sock = sock.sock(); return ret; }\r\n\r\n  buffer.resize(_rpd_chunk_size ? _rpd_chunk_size : 0x10000);\r\n\r\n  // save current file position\r\n  off_t pos = lseek(fd, 0, SEEK_CUR);\r\n\r\n  ret = read(fd, buffer.data(), buffer.size());\r\n  if(ret <= 0) return ret ? ret : -1;\r\n  _read += ret;\r\n\r\n  int size = ret, sent = 0;\r\n\r\n  ret = sock.send(buffer.data(), size-sent);\r\n  if(ret < 0) this->sock = sock.sock();\r\n  if(ret > 0) _send += ret, sent = ret;\r\n\r\n  // move file position, if buffer not fully sent\r\n  if(size != sent) lseek(fd, pos+sent, SEEK_SET);\r\n\r\n  return ret;\r\n}\r\n\r\n#if _MSC_VER > 1600\r\n\r\n//// RPD ////\r\n\r\nstruct OWLRPD : public OWL::RPD {\r\n  OWLRPD() : OWL::RPD() { }\r\n};\r\n\r\n#include \"owl_rpd.h\"\r\n\r\nOWLRPD* owlRPDCreate()\r\n{ return new OWLRPD(); }\r\n\r\nbool owlRPDRelease(struct OWLRPD **rpd)\r\n{\r\n  if(!rpd) return false;\r\n  delete *rpd;\r\n  *rpd = 0;\r\n  return true;\r\n}\r\n\r\nbool owlRPDOpen(struct OWLRPD *rpd, const char *servername, const char *filename, int mode)\r\n{\r\n  if(!rpd) return false;\r\n  bool ret = rpd->open(servername, filename, mode);\r\n  if(!ret) rpd->close();\r\n  return ret;\r\n}\r\n\r\nbool owlRPDClose(struct OWLRPD *rpd)\r\n{\r\n  if(!rpd) return false;\r\n  rpd->done();\r\n  rpd->flush();\r\n  return rpd->close();\r\n}\r\n\r\nint owlRPDSend(struct OWLRPD *rpd, long timeout)\r\n{\r\n  if(!rpd) return -1;\r\n  int ret = rpd->send(timeout);\r\n  if(ret < 0) rpd->close();\r\n  return ret;\r\n}\r\n\r\nint owlRPDRecv(struct OWLRPD *rpd, long timeout)\r\n{\r\n  if(!rpd) return -1;\r\n  int ret = rpd->recv(timeout);\r\n  if(ret < 0) rpd->close();\r\n  return ret;\r\n}\r\n\r\n#endif // _MSC_VER > 1600\r\n"}],"trace":"{\"model\":\"CollectPhaseSpaceDataJetson\",\"sources\":[\"CollectPhaseSpaceDataJetson.cpp\",\"CollectPhaseSpaceDataJetson.h\"],\"categoricalProps\":[\"BlockName\",\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"\\u003cS2\\u003e/In1\",\"InternalData\",\"Default\",\"LocalParameters\"],\"sidPrefixes\":[\"CollectPhaseSpaceDataJetson\",\"C\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[55,3,55,9],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[55,10,55,13],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[55,13,55,14],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[55,14,55,16],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[55,16,55,17],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[55,17,55,18],\"ct\":{\"1\":1,\"0\":0,\"2\":2}},{\"tk\":[56,3,56,9],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[56,10,56,36],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[56,36,56,37],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[56,37,56,39],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[56,39,56,40],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[56,40,56,41],\"els\":[\"1:49\"],\"ct\":{\"2\":2}},{\"tk\":[58,3,58,12],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[58,13,58,20],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[58,20,58,21],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[58,21,58,23],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[58,23,58,24],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[58,24,58,25],\"els\":[\"1:83:2\"],\"ct\":{\"2\":2}},{\"tk\":[59,3,59,9],\"ct\":{\"2\":2}},{\"tk\":[59,10,59,14],\"ct\":{\"2\":2}},{\"tk\":[59,14,59,15],\"ct\":{\"2\":2}},{\"tk\":[60,3,60,9],\"ct\":{\"2\":2}},{\"tk\":[60,10,60,12],\"ct\":{\"2\":2}},{\"tk\":[60,12,60,13],\"ct\":{\"2\":2}},{\"tk\":[61,3,61,9],\"ct\":{\"2\":2}},{\"tk\":[61,10,61,12],\"ct\":{\"2\":2}},{\"tk\":[61,12,61,13],\"ct\":{\"2\":2}},{\"tk\":[62,3,62,9],\"ct\":{\"2\":2}},{\"tk\":[62,10,62,12],\"ct\":{\"2\":2}},{\"tk\":[62,12,62,13],\"ct\":{\"2\":2}},{\"tk\":[63,3,63,9],\"ct\":{\"2\":2}},{\"tk\":[63,10,63,12],\"ct\":{\"2\":2}},{\"tk\":[63,12,63,13],\"ct\":{\"2\":2}},{\"tk\":[64,3,64,9],\"ct\":{\"2\":2}},{\"tk\":[64,10,64,12],\"ct\":{\"2\":2}},{\"tk\":[64,12,64,13],\"ct\":{\"2\":2}},{\"tk\":[65,3,65,9],\"ct\":{\"2\":2}},{\"tk\":[65,10,65,12],\"ct\":{\"2\":2}},{\"tk\":[65,12,65,13],\"ct\":{\"2\":2}},{\"tk\":[70,3,70,34],\"els\":[\"1:49\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[70,35,70,38],\"els\":[\"1:49\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[70,38,70,39],\"els\":[\"1:49\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,3,71,9],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,10,71,29],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,29,71,30],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,30,71,33],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,33,71,34],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[71,34,71,35],\"els\":[\"1:124\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,3,72,9],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,10,72,29],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,29,72,30],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,30,72,33],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,33,72,34],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[72,34,72,35],\"els\":[\"1:125\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,3,73,9],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,10,73,29],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,29,73,30],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,30,73,33],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,33,73,34],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[73,34,73,35],\"els\":[\"1:123\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,3,74,9],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,10,74,29],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,29,74,30],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,30,74,33],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,33,74,34],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[74,34,74,35],\"els\":[\"1:120\"],\"ct\":{\"1\":1,\"2\":2}},{\"tk\":[79,3,79,10],\"els\":[\"1:120\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[79,11,79,30],\"els\":[\"1:120\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[79,30,79,31],\"els\":[\"1:120\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[82,3,82,9],\"els\":[\"1:97\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[82,10,82,17],\"els\":[\"1:97\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[82,17,82,18],\"els\":[\"1:97\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[85,3,85,9],\"els\":[\"1:49\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[85,10,85,41],\"els\":[\"1:49\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[85,41,85,42],\"els\":[\"1:49\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[88,3,88,9],\"els\":[\"1:83:3\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[88,10,88,24],\"els\":[\"1:83:3\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[88,24,88,25],\"els\":[\"1:83:3\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[91,3,91,10],\"els\":[\"1:124\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[91,11,91,24],\"els\":[\"1:124\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[91,24,91,25],\"els\":[\"1:124\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[94,3,94,10],\"els\":[\"1:125\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[94,11,94,24],\"els\":[\"1:125\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[94,24,94,25],\"els\":[\"1:125\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[97,3,97,10],\"els\":[\"1:123\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[97,11,97,24],\"els\":[\"1:123\"],\"ct\":{\"1\":3,\"2\":2}},{\"tk\":[97,24,97,25],\"els\":[\"1:123\"],\"ct\":{\"1\":3,\"2\":2}}]},\"0\":{\"records\":[{\"tk\":[49,3,49,5],\"els\":[\"0:49\"]},{\"tk\":[49,7,49,37],\"els\":[\"0:49\"]},{\"tk\":[49,38,49,41],\"els\":[\"0:49\"]},{\"tk\":[49,56,49,58],\"els\":[\"0:49\"]},{\"tk\":[50,7,50,36],\"els\":[\"0:49\"]},{\"tk\":[50,37,50,68],\"els\":[\"0:49\"]},{\"tk\":[51,5,51,35],\"els\":[\"0:49\"]},{\"tk\":[51,36,51,39],\"els\":[\"0:49\"]},{\"tk\":[51,40,51,53],\"els\":[\"0:49\"]},{\"tk\":[51,54,51,55],\"els\":[\"0:49\"]},{\"tk\":[52,7,52,36],\"els\":[\"0:49\"]},{\"tk\":[52,37,52,68],\"els\":[\"0:49\"]},{\"tk\":[56,3,56,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1584-1586,#115\",\"0:49\"]},{\"tk\":[56,33,56,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1584-1586,#115\",\"0:49\"]},{\"tk\":[56,38,56,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1584-1598,#115\",\"0:49\"]},{\"tk\":[56,40,56,43],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1596-1597,#115\",\"0:49\"]},{\"tk\":[57,3,57,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1612-1614,#115\",\"0:49\"]},{\"tk\":[57,33,57,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1612-1614,#115\",\"0:49\"]},{\"tk\":[57,36,57,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1612-1626,#115\",\"0:49\"]},{\"tk\":[57,38,57,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1624-1625,#115\",\"0:49\"]},{\"tk\":[58,3,58,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[58,33,58,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[58,59,58,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[58,60,58,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[58,63,58,64],\"els\":[\"0:49\",\"0:49#out:1\",\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1640-1654,#115\"]},{\"tk\":[58,65,58,68],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1652-1653,#115\",\"0:49\"]},{\"tk\":[59,3,59,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1668-1670,#115\",\"0:49\"]},{\"tk\":[59,33,59,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1668-1670,#115\",\"0:49\"]},{\"tk\":[59,36,59,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1668-1682,#115\",\"0:49\"]},{\"tk\":[59,38,59,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1680-1681,#115\",\"0:49\"]},{\"tk\":[60,3,60,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1696-1698,#115\",\"0:49\"]},{\"tk\":[60,33,60,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1696-1698,#115\",\"0:49\"]},{\"tk\":[60,36,60,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1696-1710,#115\",\"0:49\"]},{\"tk\":[60,38,60,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1708-1709,#115\",\"0:49\"]},{\"tk\":[61,3,61,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[61,33,61,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[61,59,61,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[61,60,61,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[61,63,61,64],\"els\":[\"0:49\",\"0:49#out:1\",\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1724-1738,#115\"]},{\"tk\":[61,65,61,68],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1736-1737,#115\",\"0:49\"]},{\"tk\":[62,3,62,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1752-1754,#115\",\"0:49\"]},{\"tk\":[62,33,62,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1752-1754,#115\",\"0:49\"]},{\"tk\":[62,36,62,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1752-1766,#115\",\"0:49\"]},{\"tk\":[62,38,62,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1764-1765,#115\",\"0:49\"]},{\"tk\":[63,3,63,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1780-1782,#115\",\"0:49\"]},{\"tk\":[63,33,63,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1780-1782,#115\",\"0:49\"]},{\"tk\":[63,36,63,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1780-1794,#115\",\"0:49\"]},{\"tk\":[63,38,63,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1792-1793,#115\",\"0:49\"]},{\"tk\":[64,3,64,32],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1808-1810,#115\",\"0:49\"]},{\"tk\":[64,33,64,35],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1808-1810,#115\",\"0:49\"]},{\"tk\":[64,36,64,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1808-1822,#115\",\"0:49\"]},{\"tk\":[64,38,64,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1820-1821,#115\",\"0:49\"]},{\"tk\":[65,3,65,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1836-1839,#115\"]},{\"tk\":[65,7,65,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1836-1851,#115\",\"0:49\"]},{\"tk\":[65,9,65,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1849-1850,#115\",\"0:49\"]},{\"tk\":[66,3,66,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1865-1868,#115\"]},{\"tk\":[66,7,66,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1865-1880,#115\",\"0:49\"]},{\"tk\":[66,9,66,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1878-1879,#115\",\"0:49\"]},{\"tk\":[67,3,67,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1894-1897,#115\"]},{\"tk\":[67,7,67,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1894-1909,#115\",\"0:49\"]},{\"tk\":[67,9,67,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1907-1908,#115\",\"0:49\"]},{\"tk\":[68,3,68,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1923-1926,#115\"]},{\"tk\":[68,7,68,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1923-1938,#115\",\"0:49\"]},{\"tk\":[68,9,68,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1936-1937,#115\",\"0:49\"]},{\"tk\":[69,3,69,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1952-1955,#115\"]},{\"tk\":[69,7,69,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1952-1967,#115\",\"0:49\"]},{\"tk\":[69,9,69,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1965-1966,#115\",\"0:49\"]},{\"tk\":[70,3,70,6],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1981-1984,#115\"]},{\"tk\":[70,7,70,8],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1981-1996,#115\",\"0:49\"]},{\"tk\":[70,9,70,12],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1994-1995,#115\",\"0:49\"]},{\"tk\":[71,3,71,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[71,33,71,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[71,59,71,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[71,60,71,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[71,64,71,65],\"els\":[\"0:49\",\"0:49#out:1\",\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2010-2025,#115\"]},{\"tk\":[71,66,71,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2023-2024,#115\",\"0:49\"]},{\"tk\":[72,3,72,20],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2220-2648,#115\",\"0:49\"]},{\"tk\":[72,22,72,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2262-2264,#115\",\"0:49\"]},{\"tk\":[72,52,72,56],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2262-2264,#115\",\"0:49\"]},{\"tk\":[73,22,73,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2309-2311,#115\",\"0:49\"]},{\"tk\":[73,52,73,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2309-2311,#115\",\"0:49\"]},{\"tk\":[74,22,74,51],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[74,52,74,78],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[74,78,74,79],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[74,79,74,80],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[75,22,75,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2337-2339,#115\",\"0:49\"]},{\"tk\":[75,52,75,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2337-2339,#115\",\"0:49\"]},{\"tk\":[76,22,76,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2384-2386,#115\",\"0:49\"]},{\"tk\":[76,52,76,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2384-2386,#115\",\"0:49\"]},{\"tk\":[77,22,77,51],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[77,52,77,78],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[77,78,77,79],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[77,79,77,80],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[78,22,78,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2412-2414,#115\",\"0:49\"]},{\"tk\":[78,52,78,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2412-2414,#115\",\"0:49\"]},{\"tk\":[79,22,79,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2459-2461,#115\",\"0:49\"]},{\"tk\":[79,52,79,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2459-2461,#115\",\"0:49\"]},{\"tk\":[80,22,80,51],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2473-2475,#115\",\"0:49\"]},{\"tk\":[80,52,80,54],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2473-2475,#115\",\"0:49\"]},{\"tk\":[80,57,80,60],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1836-1839,#115\"]},{\"tk\":[80,63,80,66],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1865-1868,#115\"]},{\"tk\":[80,69,80,72],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1894-1897,#115\"]},{\"tk\":[80,75,80,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1923-1926,#115\"]},{\"tk\":[81,22,81,25],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1952-1955,#115\"]},{\"tk\":[81,28,81,31],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1981-1984,#115\"]},{\"tk\":[82,22,82,51],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[82,52,82,78],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[82,78,82,79],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[82,79,82,81],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[83,3,83,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[83,33,83,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[83,59,83,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[83,60,83,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[83,63,83,64],\"els\":[\"0:49\"]},{\"tk\":[84,5,84,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2671-2673,#115\",\"0:49\"]},{\"tk\":[84,35,84,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2671-2673,#115\",\"0:49\"]},{\"tk\":[84,38,84,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2671-2691,#115\",\"0:49\"]},{\"tk\":[85,5,85,35],\"els\":[\"0:49\"]},{\"tk\":[85,36,85,39],\"els\":[\"0:49\"]},{\"tk\":[86,3,86,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[86,33,86,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[86,59,86,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[86,60,86,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[86,63,86,64],\"els\":[\"0:49\"]},{\"tk\":[87,5,87,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2693-2695,#115\",\"0:49\"]},{\"tk\":[87,35,87,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2693-2695,#115\",\"0:49\"]},{\"tk\":[87,40,87,41],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2693-2700,#115\",\"0:49\"]},{\"tk\":[87,42,87,48],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2696-2700,#115\",\"0:49\"]},{\"tk\":[88,3,88,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[88,33,88,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[88,59,88,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[88,60,88,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[88,63,88,64],\"els\":[\"0:49\"]},{\"tk\":[89,5,89,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2702-2704,#115\",\"0:49\"]},{\"tk\":[89,35,89,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2702-2704,#115\",\"0:49\"]},{\"tk\":[89,38,89,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2702-2709,#115\",\"0:49\"]},{\"tk\":[89,40,89,46],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2705-2709,#115\",\"0:49\"]},{\"tk\":[90,3,90,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[90,33,90,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[90,59,90,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[90,60,90,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[90,63,90,64],\"els\":[\"0:49\"]},{\"tk\":[91,5,91,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2715-2717,#115\",\"0:49\"]},{\"tk\":[91,35,91,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2715-2717,#115\",\"0:49\"]},{\"tk\":[91,38,91,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2715-2722,#115\",\"0:49\"]},{\"tk\":[91,40,91,46],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2718-2722,#115\",\"0:49\"]},{\"tk\":[92,3,92,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[92,33,92,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[92,59,92,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[92,60,92,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[92,63,92,64],\"els\":[\"0:49\"]},{\"tk\":[93,5,93,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2724-2726,#115\",\"0:49\"]},{\"tk\":[93,35,93,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2724-2726,#115\",\"0:49\"]},{\"tk\":[93,38,93,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2724-2731,#115\",\"0:49\"]},{\"tk\":[93,40,93,46],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2727-2731,#115\",\"0:49\"]},{\"tk\":[94,3,94,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[94,33,94,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[94,59,94,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[94,60,94,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[94,63,94,64],\"els\":[\"0:49\"]},{\"tk\":[95,5,95,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2760-2762,#115\",\"0:49\"]},{\"tk\":[95,35,95,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2760-2762,#115\",\"0:49\"]},{\"tk\":[95,38,95,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2760-2767,#115\",\"0:49\"]},{\"tk\":[95,40,95,46],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2763-2767,#115\",\"0:49\"]},{\"tk\":[96,3,96,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[96,33,96,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[96,59,96,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[96,60,96,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[96,63,96,64],\"els\":[\"0:49\"]},{\"tk\":[97,5,97,34],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2769-2771,#115\",\"0:49\"]},{\"tk\":[97,35,97,37],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2769-2771,#115\",\"0:49\"]},{\"tk\":[97,38,97,39],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2769-2776,#115\",\"0:49\"]},{\"tk\":[97,40,97,46],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2772-2776,#115\",\"0:49\"]},{\"tk\":[98,3,98,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[98,33,98,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[98,59,98,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[98,60,98,61],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[98,63,98,64],\"els\":[\"0:49\"]},{\"tk\":[98,65,98,68],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1836-1839,#115\"]},{\"tk\":[98,69,98,70],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2778-2786,#115\",\"0:49\"]},{\"tk\":[98,71,98,77],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2782-2786,#115\",\"0:49\"]},{\"tk\":[99,3,99,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[99,33,99,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[99,59,99,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[99,60,99,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[99,64,99,65],\"els\":[\"0:49\"]},{\"tk\":[99,66,99,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1865-1868,#115\"]},{\"tk\":[99,70,99,71],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2788-2796,#115\",\"0:49\"]},{\"tk\":[99,72,99,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2792-2796,#115\",\"0:49\"]},{\"tk\":[100,3,100,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[100,33,100,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[100,59,100,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[100,60,100,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[100,64,100,65],\"els\":[\"0:49\"]},{\"tk\":[100,66,100,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1894-1897,#115\"]},{\"tk\":[100,70,100,71],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2798-2806,#115\",\"0:49\"]},{\"tk\":[100,72,100,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2802-2806,#115\",\"0:49\"]},{\"tk\":[101,3,101,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[101,33,101,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[101,59,101,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[101,60,101,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[101,64,101,65],\"els\":[\"0:49\"]},{\"tk\":[101,66,101,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1923-1926,#115\"]},{\"tk\":[101,70,101,71],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2808-2816,#115\",\"0:49\"]},{\"tk\":[101,72,101,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2812-2816,#115\",\"0:49\"]},{\"tk\":[102,3,102,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[102,33,102,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[102,59,102,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[102,60,102,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[102,64,102,65],\"els\":[\"0:49\"]},{\"tk\":[102,66,102,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1952-1955,#115\"]},{\"tk\":[102,70,102,71],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2841-2849,#115\",\"0:49\"]},{\"tk\":[102,72,102,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2845-2849,#115\",\"0:49\"]},{\"tk\":[103,3,103,32],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[103,33,103,59],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[103,59,103,60],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[103,60,103,62],\"els\":[\"0:49\",\"0:49#out:1\"]},{\"tk\":[103,64,103,65],\"els\":[\"0:49\"]},{\"tk\":[103,66,103,69],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1981-1984,#115\"]},{\"tk\":[103,70,103,71],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2851-2859,#115\",\"0:49\"]},{\"tk\":[103,72,103,78],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:2855-2859,#115\",\"0:49\"]},{\"tk\":[111,3,111,6],\"els\":[\"0:83:2\"]},{\"tk\":[111,16,111,17],\"els\":[\"0:83:2\"]},{\"tk\":[111,20,111,21],\"els\":[\"0:83:2\"]},{\"tk\":[111,23,111,24],\"els\":[\"0:83:2\"]},{\"tk\":[111,27,111,29],\"els\":[\"0:83:2\"]},{\"tk\":[111,31,111,32],\"els\":[\"0:83:2\"]},{\"tk\":[111,32,111,34],\"els\":[\"0:83:2\"]},{\"tk\":[112,5,112,34],\"els\":[\"0:83:2\",\"0:83:2#out:1\"]},{\"tk\":[112,35,112,42],\"els\":[\"0:83:2\",\"0:83:2#out:1\"]},{\"tk\":[112,42,112,43],\"els\":[\"0:83:2\",\"0:83:2#out:1\"]},{\"tk\":[112,43,112,44],\"els\":[\"0:83:2\"]},{\"tk\":[112,46,112,47],\"els\":[\"0:83:2\"]},{\"tk\":[113,8,113,37],\"els\":[\"0:83:2\",\"0:49#out:1\"]},{\"tk\":[113,38,113,64],\"els\":[\"0:83:2\",\"0:49#out:1\"]},{\"tk\":[113,64,113,65],\"els\":[\"0:83:2\",\"0:49#out:1\"]},{\"tk\":[113,65,113,66],\"els\":[\"0:83:2\"]},{\"tk\":[113,68,113,70],\"els\":[\"0:83:2\"]},{\"tk\":[114,8,114,37],\"els\":[\"0:83:3\"]},{\"tk\":[114,38,114,52],\"els\":[\"0:83:3\"]},{\"tk\":[123,3,123,5],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[123,7,123,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[123,37,123,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[123,44,123,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[123,45,123,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[123,48,123,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[124,7,124,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[124,37,124,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[124,44,124,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[124,45,124,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[124,48,124,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[125,7,125,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[125,37,125,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[125,44,125,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[125,45,125,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[125,48,125,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[126,7,126,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[126,37,126,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[126,44,126,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[126,45,126,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[126,48,126,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[127,7,127,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[127,37,127,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[127,44,127,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[127,45,127,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[127,48,127,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[128,7,128,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[128,37,128,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[128,44,128,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[128,45,128,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[128,48,128,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[129,7,129,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[129,37,129,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[129,44,129,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[129,45,129,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[129,48,129,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[130,7,130,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[130,37,130,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[130,44,130,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[130,45,130,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[130,48,130,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[131,7,131,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[131,37,131,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[131,44,131,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[131,45,131,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[131,48,131,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[132,7,132,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[132,37,132,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[132,44,132,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[132,45,132,46],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[132,48,132,50],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[133,7,133,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[133,37,133,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[133,44,133,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[133,45,133,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[133,49,133,51],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[134,7,134,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[134,37,134,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[134,44,134,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[134,45,134,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[134,49,134,51],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[135,7,135,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[135,37,135,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[135,44,135,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[135,45,135,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[135,49,135,51],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[136,7,136,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[136,37,136,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[136,44,136,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[136,45,136,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[136,49,136,51],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[137,7,137,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[137,37,137,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[137,44,137,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[137,45,137,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[137,49,137,51],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[138,7,138,36],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[138,37,138,44],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[138,44,138,45],\"els\":[\"0:96\",\"0:94\",\"0:83:2#out:1\"]},{\"tk\":[138,45,138,47],\"els\":[\"0:96\",\"0:94\"]},{\"tk\":[142,5,142,8],\"els\":[\"0:95\",\"0:96\",\"0:94\"]},{\"tk\":[142,18,142,47],\"els\":[\"0:95\"]},{\"tk\":[142,48,142,51],\"els\":[\"0:95\"]},{\"tk\":[142,51,142,52],\"els\":[\"0:95\"]},{\"tk\":[142,52,142,53],\"els\":[\"0:95\",\"0:96\",\"0:94\"]},{\"tk\":[143,18,143,47],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[143,48,143,74],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[143,74,143,75],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[143,75,143,76],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[144,17,144,23],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[144,32,144,34],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[144,35,144,37],\"els\":[\"0:95\",\"0:96\",\"0:94\",\"0:49#out:1\"]},{\"tk\":[152,3,152,7],\"els\":[\"0:124\"]},{\"tk\":[152,8,152,9],\"els\":[\"0:124\"]},{\"tk\":[152,10,152,24],\"els\":[\"0:124\"]},{\"tk\":[152,26,152,56],\"els\":[\"0:124\"]},{\"tk\":[152,57,152,76],\"els\":[\"0:124\"]},{\"tk\":[152,76,152,77],\"els\":[\"0:124\"]},{\"tk\":[152,77,152,79],\"els\":[\"0:124\"]},{\"tk\":[153,3,153,20],\"els\":[\"0:124\"]},{\"tk\":[153,22,153,52],\"els\":[\"0:124\"]},{\"tk\":[153,53,153,72],\"els\":[\"0:124\"]},{\"tk\":[153,72,153,73],\"els\":[\"0:124\"]},{\"tk\":[153,73,153,75],\"els\":[\"0:124\"]},{\"tk\":[154,22,154,51],\"els\":[\"0:95\"]},{\"tk\":[154,52,154,55],\"els\":[\"0:95\"]},{\"tk\":[154,55,154,56],\"els\":[\"0:95\",\"0:124\"]},{\"tk\":[154,56,154,58],\"els\":[\"0:124\"]},{\"tk\":[154,61,154,63],\"els\":[\"0:124\"]},{\"tk\":[155,3,155,5],\"els\":[\"0:124\"]},{\"tk\":[155,7,155,8],\"els\":[\"0:124\"]},{\"tk\":[155,8,155,12],\"els\":[\"0:124\"]},{\"tk\":[155,13,155,15],\"els\":[\"0:124\"]},{\"tk\":[155,16,155,17],\"els\":[\"0:124\"]},{\"tk\":[156,5,156,22],\"els\":[\"0:124\"]},{\"tk\":[156,22,156,23],\"els\":[\"0:124\"]},{\"tk\":[156,23,156,52],\"els\":[\"0:124\"]},{\"tk\":[156,52,156,53],\"els\":[\"0:124\"]},{\"tk\":[156,54,156,58],\"els\":[\"0:124\"]},{\"tk\":[156,58,156,59],\"els\":[\"0:124\"]},{\"tk\":[157,5,157,24],\"els\":[\"0:124\"]},{\"tk\":[157,24,157,25],\"els\":[\"0:124\"]},{\"tk\":[157,25,157,54],\"els\":[\"0:124\"]},{\"tk\":[157,54,157,55],\"els\":[\"0:124\"]},{\"tk\":[157,56,157,57],\"els\":[\"0:124\"]},{\"tk\":[157,57,157,58],\"els\":[\"0:124\"]},{\"tk\":[165,3,165,7],\"els\":[\"0:124\"]},{\"tk\":[165,8,165,9],\"els\":[\"0:125\"]},{\"tk\":[165,10,165,24],\"els\":[\"0:125\"]},{\"tk\":[165,26,165,56],\"els\":[\"0:125\"]},{\"tk\":[165,57,165,76],\"els\":[\"0:125\"]},{\"tk\":[165,76,165,77],\"els\":[\"0:125\"]},{\"tk\":[165,77,165,79],\"els\":[\"0:125\"]},{\"tk\":[166,3,166,20],\"els\":[\"0:125\"]},{\"tk\":[166,22,166,52],\"els\":[\"0:125\"]},{\"tk\":[166,53,166,72],\"els\":[\"0:125\"]},{\"tk\":[166,72,166,73],\"els\":[\"0:125\"]},{\"tk\":[166,73,166,75],\"els\":[\"0:125\"]},{\"tk\":[167,22,167,51],\"els\":[\"0:95\"]},{\"tk\":[167,52,167,55],\"els\":[\"0:95\"]},{\"tk\":[167,55,167,56],\"els\":[\"0:95\",\"0:125\"]},{\"tk\":[167,56,167,58],\"els\":[\"0:125\"]},{\"tk\":[167,61,167,63],\"els\":[\"0:125\"]},{\"tk\":[168,3,168,5],\"els\":[\"0:125\"]},{\"tk\":[168,7,168,8],\"els\":[\"0:125\"]},{\"tk\":[168,8,168,12],\"els\":[\"0:124\"]},{\"tk\":[168,13,168,15],\"els\":[\"0:125\"]},{\"tk\":[168,16,168,17],\"els\":[\"0:125\"]},{\"tk\":[169,5,169,22],\"els\":[\"0:125\"]},{\"tk\":[169,22,169,23],\"els\":[\"0:125\"]},{\"tk\":[169,23,169,52],\"els\":[\"0:125\"]},{\"tk\":[169,52,169,53],\"els\":[\"0:125\"]},{\"tk\":[169,54,169,58],\"els\":[\"0:124\",\"0:125\"]},{\"tk\":[169,58,169,59],\"els\":[\"0:125\"]},{\"tk\":[170,5,170,24],\"els\":[\"0:125\"]},{\"tk\":[170,24,170,25],\"els\":[\"0:125\"]},{\"tk\":[170,25,170,54],\"els\":[\"0:125\"]},{\"tk\":[170,54,170,55],\"els\":[\"0:125\"]},{\"tk\":[170,56,170,57],\"els\":[\"0:125\"]},{\"tk\":[170,57,170,58],\"els\":[\"0:125\"]},{\"tk\":[178,3,178,7],\"els\":[\"0:124\"]},{\"tk\":[178,8,178,9],\"els\":[\"0:123\"]},{\"tk\":[178,10,178,24],\"els\":[\"0:123\"]},{\"tk\":[178,26,178,56],\"els\":[\"0:123\"]},{\"tk\":[178,57,178,76],\"els\":[\"0:123\"]},{\"tk\":[178,76,178,77],\"els\":[\"0:123\"]},{\"tk\":[178,77,178,79],\"els\":[\"0:123\"]},{\"tk\":[179,3,179,20],\"els\":[\"0:123\"]},{\"tk\":[179,22,179,52],\"els\":[\"0:123\"]},{\"tk\":[179,53,179,72],\"els\":[\"0:123\"]},{\"tk\":[179,72,179,73],\"els\":[\"0:123\"]},{\"tk\":[179,73,179,75],\"els\":[\"0:123\"]},{\"tk\":[180,22,180,51],\"els\":[\"0:95\"]},{\"tk\":[180,52,180,55],\"els\":[\"0:95\"]},{\"tk\":[180,55,180,56],\"els\":[\"0:95\",\"0:123\"]},{\"tk\":[180,56,180,58],\"els\":[\"0:123\"]},{\"tk\":[180,61,180,63],\"els\":[\"0:123\"]},{\"tk\":[181,3,181,5],\"els\":[\"0:123\"]},{\"tk\":[181,7,181,8],\"els\":[\"0:123\"]},{\"tk\":[181,8,181,12],\"els\":[\"0:124\"]},{\"tk\":[181,13,181,15],\"els\":[\"0:123\"]},{\"tk\":[181,16,181,17],\"els\":[\"0:123\"]},{\"tk\":[182,5,182,22],\"els\":[\"0:123\"]},{\"tk\":[182,22,182,23],\"els\":[\"0:123\"]},{\"tk\":[182,23,182,52],\"els\":[\"0:123\"]},{\"tk\":[182,52,182,53],\"els\":[\"0:123\"]},{\"tk\":[182,54,182,58],\"els\":[\"0:124\",\"0:123\"]},{\"tk\":[182,58,182,59],\"els\":[\"0:123\"]},{\"tk\":[183,5,183,24],\"els\":[\"0:123\"]},{\"tk\":[183,24,183,25],\"els\":[\"0:123\"]},{\"tk\":[183,25,183,54],\"els\":[\"0:123\"]},{\"tk\":[183,54,183,55],\"els\":[\"0:123\"]},{\"tk\":[183,56,183,57],\"els\":[\"0:123\"]},{\"tk\":[183,57,183,58],\"els\":[\"0:123\"]},{\"tk\":[191,3,191,7],\"els\":[\"0:124\"]},{\"tk\":[191,8,191,9],\"els\":[\"0:120\"]},{\"tk\":[191,10,191,24],\"els\":[\"0:120\"]},{\"tk\":[191,26,191,56],\"els\":[\"0:120\"]},{\"tk\":[191,57,191,76],\"els\":[\"0:120\"]},{\"tk\":[191,76,191,77],\"els\":[\"0:120\"]},{\"tk\":[191,77,191,79],\"els\":[\"0:120\"]},{\"tk\":[192,3,192,20],\"els\":[\"0:120\"]},{\"tk\":[192,22,192,52],\"els\":[\"0:120\"]},{\"tk\":[192,53,192,72],\"els\":[\"0:120\"]},{\"tk\":[192,72,192,73],\"els\":[\"0:120\"]},{\"tk\":[192,73,192,75],\"els\":[\"0:120\"]},{\"tk\":[193,22,193,51],\"els\":[\"0:95\"]},{\"tk\":[193,52,193,55],\"els\":[\"0:95\"]},{\"tk\":[193,55,193,56],\"els\":[\"0:95\",\"0:120\"]},{\"tk\":[193,56,193,58],\"els\":[\"0:120\"]},{\"tk\":[193,61,193,63],\"els\":[\"0:120\"]},{\"tk\":[194,3,194,5],\"els\":[\"0:120\"]},{\"tk\":[194,7,194,8],\"els\":[\"0:120\"]},{\"tk\":[194,8,194,12],\"els\":[\"0:124\"]},{\"tk\":[194,13,194,15],\"els\":[\"0:120\"]},{\"tk\":[194,16,194,17],\"els\":[\"0:120\"]},{\"tk\":[195,5,195,22],\"els\":[\"0:120\"]},{\"tk\":[195,22,195,23],\"els\":[\"0:120\"]},{\"tk\":[195,23,195,52],\"els\":[\"0:120\"]},{\"tk\":[195,52,195,53],\"els\":[\"0:120\"]},{\"tk\":[195,54,195,58],\"els\":[\"0:124\",\"0:120\"]},{\"tk\":[195,58,195,59],\"els\":[\"0:120\"]},{\"tk\":[196,5,196,24],\"els\":[\"0:120\"]},{\"tk\":[196,24,196,25],\"els\":[\"0:120\"]},{\"tk\":[196,25,196,54],\"els\":[\"0:120\"]},{\"tk\":[196,54,196,55],\"els\":[\"0:120\"]},{\"tk\":[196,56,196,57],\"els\":[\"0:120\"]},{\"tk\":[196,57,196,58],\"els\":[\"0:120\"]},{\"tk\":[209,5,209,9],\"els\":[\"0:124\"]},{\"tk\":[209,10,209,11],\"els\":[\"0:124\"]},{\"tk\":[209,12,209,26],\"els\":[\"0:124\"]},{\"tk\":[209,28,209,58],\"els\":[\"0:124\"]},{\"tk\":[209,59,209,78],\"els\":[\"0:124\"]},{\"tk\":[209,78,209,79],\"els\":[\"0:124\"]},{\"tk\":[209,79,209,81],\"els\":[\"0:124\"]},{\"tk\":[210,5,210,23],\"els\":[\"0:124\"]},{\"tk\":[210,25,210,55],\"els\":[\"0:124\"]},{\"tk\":[210,56,210,75],\"els\":[\"0:124\"]},{\"tk\":[210,75,210,76],\"els\":[\"0:124\"]},{\"tk\":[210,76,210,78],\"els\":[\"0:124\"]},{\"tk\":[211,5,211,7],\"els\":[\"0:124\"]},{\"tk\":[211,9,211,10],\"els\":[\"0:124\"]},{\"tk\":[211,10,211,14],\"els\":[\"0:124\"]},{\"tk\":[211,15,211,17],\"els\":[\"0:124\"]},{\"tk\":[211,18,211,19],\"els\":[\"0:124\"]},{\"tk\":[212,7,212,24],\"els\":[\"0:124\"]},{\"tk\":[212,26,212,56],\"els\":[\"0:124\"]},{\"tk\":[212,57,212,76],\"els\":[\"0:124\"]},{\"tk\":[212,76,212,77],\"els\":[\"0:124\"]},{\"tk\":[212,77,212,79],\"els\":[\"0:124\"]},{\"tk\":[213,25,213,26],\"els\":[\"0:124\"]},{\"tk\":[213,28,213,37],\"els\":[\"0:124\"]},{\"tk\":[213,39,213,40],\"els\":[\"0:124\"]},{\"tk\":[213,43,213,58],\"els\":[\"0:124\"]},{\"tk\":[214,25,214,54],\"els\":[\"0:124\"]},{\"tk\":[214,55,214,68],\"els\":[\"0:124\"]},{\"tk\":[214,70,214,74],\"els\":[\"0:124\"]},{\"tk\":[214,76,214,77],\"els\":[\"0:124\"]},{\"tk\":[214,79,214,80],\"els\":[\"0:124\"]},{\"tk\":[217,5,217,7],\"els\":[\"0:124\"]},{\"tk\":[217,9,217,10],\"els\":[\"0:124\"]},{\"tk\":[217,10,217,14],\"els\":[\"0:124\"]},{\"tk\":[217,15,217,17],\"els\":[\"0:124\"]},{\"tk\":[217,18,217,19],\"els\":[\"0:124\"]},{\"tk\":[218,7,218,15],\"els\":[\"0:124\"]},{\"tk\":[218,17,218,47],\"els\":[\"0:124\"]},{\"tk\":[218,48,218,67],\"els\":[\"0:124\"]},{\"tk\":[218,67,218,68],\"els\":[\"0:124\"]},{\"tk\":[218,68,218,70],\"els\":[\"0:124\"]},{\"tk\":[221,5,221,7],\"els\":[\"0:124\"]},{\"tk\":[221,9,221,10],\"els\":[\"0:124\"]},{\"tk\":[221,10,221,14],\"els\":[\"0:124\"]},{\"tk\":[221,15,221,17],\"els\":[\"0:124\"]},{\"tk\":[221,18,221,19],\"els\":[\"0:124\"]},{\"tk\":[222,7,222,26],\"els\":[\"0:124\"]},{\"tk\":[222,28,222,58],\"els\":[\"0:124\"]},{\"tk\":[222,59,222,78],\"els\":[\"0:124\"]},{\"tk\":[222,78,222,79],\"els\":[\"0:124\"]},{\"tk\":[222,79,222,81],\"els\":[\"0:124\"]},{\"tk\":[223,7,223,9],\"els\":[\"0:124\"]},{\"tk\":[223,11,223,12],\"els\":[\"0:124\"]},{\"tk\":[223,12,223,16],\"els\":[\"0:124\"]},{\"tk\":[223,17,223,19],\"els\":[\"0:124\"]},{\"tk\":[223,20,223,21],\"els\":[\"0:124\"]},{\"tk\":[224,9,224,26],\"els\":[\"0:124\"]},{\"tk\":[224,26,224,27],\"els\":[\"0:124\"]},{\"tk\":[224,27,224,56],\"els\":[\"0:124\"]},{\"tk\":[224,56,224,57],\"els\":[\"0:124\"]},{\"tk\":[224,58,224,62],\"els\":[\"0:124\"]},{\"tk\":[224,62,224,63],\"els\":[\"0:124\"]},{\"tk\":[225,9,225,28],\"els\":[\"0:124\"]},{\"tk\":[225,28,225,29],\"els\":[\"0:124\"]},{\"tk\":[225,29,225,58],\"els\":[\"0:124\"]},{\"tk\":[225,58,225,59],\"els\":[\"0:124\"]},{\"tk\":[225,60,225,61],\"els\":[\"0:124\"]},{\"tk\":[225,61,225,62],\"els\":[\"0:124\"]},{\"tk\":[232,5,232,9],\"els\":[\"0:124\"]},{\"tk\":[232,10,232,11],\"els\":[\"0:125\"]},{\"tk\":[232,12,232,26],\"els\":[\"0:125\"]},{\"tk\":[232,28,232,58],\"els\":[\"0:125\"]},{\"tk\":[232,59,232,78],\"els\":[\"0:125\"]},{\"tk\":[232,78,232,79],\"els\":[\"0:125\"]},{\"tk\":[232,79,232,81],\"els\":[\"0:125\"]},{\"tk\":[233,5,233,23],\"els\":[\"0:125\"]},{\"tk\":[233,25,233,55],\"els\":[\"0:125\"]},{\"tk\":[233,56,233,75],\"els\":[\"0:125\"]},{\"tk\":[233,75,233,76],\"els\":[\"0:125\"]},{\"tk\":[233,76,233,78],\"els\":[\"0:125\"]},{\"tk\":[234,5,234,7],\"els\":[\"0:125\"]},{\"tk\":[234,9,234,10],\"els\":[\"0:125\"]},{\"tk\":[234,10,234,14],\"els\":[\"0:124\"]},{\"tk\":[234,15,234,17],\"els\":[\"0:125\"]},{\"tk\":[234,18,234,19],\"els\":[\"0:125\"]},{\"tk\":[235,7,235,24],\"els\":[\"0:125\"]},{\"tk\":[235,26,235,56],\"els\":[\"0:125\"]},{\"tk\":[235,57,235,76],\"els\":[\"0:125\"]},{\"tk\":[235,76,235,77],\"els\":[\"0:125\"]},{\"tk\":[235,77,235,79],\"els\":[\"0:125\"]},{\"tk\":[236,25,236,26],\"els\":[\"0:125\"]},{\"tk\":[236,28,236,37],\"els\":[\"0:125\"]},{\"tk\":[236,39,236,40],\"els\":[\"0:125\"]},{\"tk\":[236,43,236,58],\"els\":[\"0:125\"]},{\"tk\":[237,25,237,54],\"els\":[\"0:125\"]},{\"tk\":[237,55,237,68],\"els\":[\"0:125\"]},{\"tk\":[237,70,237,74],\"els\":[\"0:125\"]},{\"tk\":[237,76,237,77],\"els\":[\"0:125\"]},{\"tk\":[237,79,237,80],\"els\":[\"0:125\"]},{\"tk\":[240,5,240,7],\"els\":[\"0:125\"]},{\"tk\":[240,9,240,10],\"els\":[\"0:125\"]},{\"tk\":[240,10,240,14],\"els\":[\"0:124\"]},{\"tk\":[240,15,240,17],\"els\":[\"0:125\"]},{\"tk\":[240,18,240,19],\"els\":[\"0:125\"]},{\"tk\":[241,7,241,15],\"els\":[\"0:125\"]},{\"tk\":[241,17,241,47],\"els\":[\"0:125\"]},{\"tk\":[241,48,241,67],\"els\":[\"0:125\"]},{\"tk\":[241,67,241,68],\"els\":[\"0:125\"]},{\"tk\":[241,68,241,70],\"els\":[\"0:125\"]},{\"tk\":[244,5,244,7],\"els\":[\"0:125\"]},{\"tk\":[244,9,244,10],\"els\":[\"0:125\"]},{\"tk\":[244,10,244,14],\"els\":[\"0:124\"]},{\"tk\":[244,15,244,17],\"els\":[\"0:125\"]},{\"tk\":[244,18,244,19],\"els\":[\"0:125\"]},{\"tk\":[245,7,245,26],\"els\":[\"0:125\"]},{\"tk\":[245,28,245,58],\"els\":[\"0:125\"]},{\"tk\":[245,59,245,78],\"els\":[\"0:125\"]},{\"tk\":[245,78,245,79],\"els\":[\"0:125\"]},{\"tk\":[245,79,245,81],\"els\":[\"0:125\"]},{\"tk\":[246,7,246,9],\"els\":[\"0:125\"]},{\"tk\":[246,11,246,12],\"els\":[\"0:125\"]},{\"tk\":[246,12,246,16],\"els\":[\"0:124\"]},{\"tk\":[246,17,246,19],\"els\":[\"0:125\"]},{\"tk\":[246,20,246,21],\"els\":[\"0:125\"]},{\"tk\":[247,9,247,26],\"els\":[\"0:125\"]},{\"tk\":[247,26,247,27],\"els\":[\"0:125\"]},{\"tk\":[247,27,247,56],\"els\":[\"0:125\"]},{\"tk\":[247,56,247,57],\"els\":[\"0:125\"]},{\"tk\":[247,58,247,62],\"els\":[\"0:124\",\"0:125\"]},{\"tk\":[247,62,247,63],\"els\":[\"0:125\"]},{\"tk\":[248,9,248,28],\"els\":[\"0:125\"]},{\"tk\":[248,28,248,29],\"els\":[\"0:125\"]},{\"tk\":[248,29,248,58],\"els\":[\"0:125\"]},{\"tk\":[248,58,248,59],\"els\":[\"0:125\"]},{\"tk\":[248,60,248,61],\"els\":[\"0:125\"]},{\"tk\":[248,61,248,62],\"els\":[\"0:125\"]},{\"tk\":[255,5,255,9],\"els\":[\"0:124\"]},{\"tk\":[255,10,255,11],\"els\":[\"0:123\"]},{\"tk\":[255,12,255,26],\"els\":[\"0:123\"]},{\"tk\":[255,28,255,58],\"els\":[\"0:123\"]},{\"tk\":[255,59,255,78],\"els\":[\"0:123\"]},{\"tk\":[255,78,255,79],\"els\":[\"0:123\"]},{\"tk\":[255,79,255,81],\"els\":[\"0:123\"]},{\"tk\":[256,5,256,23],\"els\":[\"0:123\"]},{\"tk\":[256,25,256,55],\"els\":[\"0:123\"]},{\"tk\":[256,56,256,75],\"els\":[\"0:123\"]},{\"tk\":[256,75,256,76],\"els\":[\"0:123\"]},{\"tk\":[256,76,256,78],\"els\":[\"0:123\"]},{\"tk\":[257,5,257,7],\"els\":[\"0:123\"]},{\"tk\":[257,9,257,10],\"els\":[\"0:123\"]},{\"tk\":[257,10,257,14],\"els\":[\"0:124\"]},{\"tk\":[257,15,257,17],\"els\":[\"0:123\"]},{\"tk\":[257,18,257,19],\"els\":[\"0:123\"]},{\"tk\":[258,7,258,24],\"els\":[\"0:123\"]},{\"tk\":[258,26,258,56],\"els\":[\"0:123\"]},{\"tk\":[258,57,258,76],\"els\":[\"0:123\"]},{\"tk\":[258,76,258,77],\"els\":[\"0:123\"]},{\"tk\":[258,77,258,79],\"els\":[\"0:123\"]},{\"tk\":[259,25,259,26],\"els\":[\"0:123\"]},{\"tk\":[259,28,259,37],\"els\":[\"0:123\"]},{\"tk\":[259,39,259,40],\"els\":[\"0:123\"]},{\"tk\":[259,43,259,58],\"els\":[\"0:123\"]},{\"tk\":[260,25,260,54],\"els\":[\"0:123\"]},{\"tk\":[260,55,260,68],\"els\":[\"0:123\"]},{\"tk\":[260,70,260,74],\"els\":[\"0:123\"]},{\"tk\":[260,76,260,77],\"els\":[\"0:123\"]},{\"tk\":[260,79,260,80],\"els\":[\"0:123\"]},{\"tk\":[263,5,263,7],\"els\":[\"0:123\"]},{\"tk\":[263,9,263,10],\"els\":[\"0:123\"]},{\"tk\":[263,10,263,14],\"els\":[\"0:124\"]},{\"tk\":[263,15,263,17],\"els\":[\"0:123\"]},{\"tk\":[263,18,263,19],\"els\":[\"0:123\"]},{\"tk\":[264,7,264,15],\"els\":[\"0:123\"]},{\"tk\":[264,17,264,47],\"els\":[\"0:123\"]},{\"tk\":[264,48,264,67],\"els\":[\"0:123\"]},{\"tk\":[264,67,264,68],\"els\":[\"0:123\"]},{\"tk\":[264,68,264,70],\"els\":[\"0:123\"]},{\"tk\":[267,5,267,7],\"els\":[\"0:123\"]},{\"tk\":[267,9,267,10],\"els\":[\"0:123\"]},{\"tk\":[267,10,267,14],\"els\":[\"0:124\"]},{\"tk\":[267,15,267,17],\"els\":[\"0:123\"]},{\"tk\":[267,18,267,19],\"els\":[\"0:123\"]},{\"tk\":[268,7,268,26],\"els\":[\"0:123\"]},{\"tk\":[268,28,268,58],\"els\":[\"0:123\"]},{\"tk\":[268,59,268,78],\"els\":[\"0:123\"]},{\"tk\":[268,78,268,79],\"els\":[\"0:123\"]},{\"tk\":[268,79,268,81],\"els\":[\"0:123\"]},{\"tk\":[269,7,269,9],\"els\":[\"0:123\"]},{\"tk\":[269,11,269,12],\"els\":[\"0:123\"]},{\"tk\":[269,12,269,16],\"els\":[\"0:124\"]},{\"tk\":[269,17,269,19],\"els\":[\"0:123\"]},{\"tk\":[269,20,269,21],\"els\":[\"0:123\"]},{\"tk\":[270,9,270,26],\"els\":[\"0:123\"]},{\"tk\":[270,26,270,27],\"els\":[\"0:123\"]},{\"tk\":[270,27,270,56],\"els\":[\"0:123\"]},{\"tk\":[270,56,270,57],\"els\":[\"0:123\"]},{\"tk\":[270,58,270,62],\"els\":[\"0:124\",\"0:123\"]},{\"tk\":[270,62,270,63],\"els\":[\"0:123\"]},{\"tk\":[271,9,271,28],\"els\":[\"0:123\"]},{\"tk\":[271,28,271,29],\"els\":[\"0:123\"]},{\"tk\":[271,29,271,58],\"els\":[\"0:123\"]},{\"tk\":[271,58,271,59],\"els\":[\"0:123\"]},{\"tk\":[271,60,271,61],\"els\":[\"0:123\"]},{\"tk\":[271,61,271,62],\"els\":[\"0:123\"]},{\"tk\":[278,5,278,9],\"els\":[\"0:124\"]},{\"tk\":[278,10,278,11],\"els\":[\"0:120\"]},{\"tk\":[278,12,278,26],\"els\":[\"0:120\"]},{\"tk\":[278,28,278,58],\"els\":[\"0:120\"]},{\"tk\":[278,59,278,78],\"els\":[\"0:120\"]},{\"tk\":[278,78,278,79],\"els\":[\"0:120\"]},{\"tk\":[278,79,278,81],\"els\":[\"0:120\"]},{\"tk\":[279,5,279,23],\"els\":[\"0:120\"]},{\"tk\":[279,25,279,55],\"els\":[\"0:120\"]},{\"tk\":[279,56,279,75],\"els\":[\"0:120\"]},{\"tk\":[279,75,279,76],\"els\":[\"0:120\"]},{\"tk\":[279,76,279,78],\"els\":[\"0:120\"]},{\"tk\":[280,5,280,7],\"els\":[\"0:120\"]},{\"tk\":[280,9,280,10],\"els\":[\"0:120\"]},{\"tk\":[280,10,280,14],\"els\":[\"0:124\"]},{\"tk\":[280,15,280,17],\"els\":[\"0:120\"]},{\"tk\":[280,18,280,19],\"els\":[\"0:120\"]},{\"tk\":[281,7,281,24],\"els\":[\"0:120\"]},{\"tk\":[281,26,281,56],\"els\":[\"0:120\"]},{\"tk\":[281,57,281,76],\"els\":[\"0:120\"]},{\"tk\":[281,76,281,77],\"els\":[\"0:120\"]},{\"tk\":[281,77,281,79],\"els\":[\"0:120\"]},{\"tk\":[282,25,282,26],\"els\":[\"0:120\"]},{\"tk\":[282,28,282,37],\"els\":[\"0:120\"]},{\"tk\":[282,39,282,40],\"els\":[\"0:120\"]},{\"tk\":[282,43,282,58],\"els\":[\"0:120\"]},{\"tk\":[283,25,283,54],\"els\":[\"0:120\"]},{\"tk\":[283,55,283,74],\"els\":[\"0:120\"]},{\"tk\":[283,76,283,80],\"els\":[\"0:120\"]},{\"tk\":[284,25,284,26],\"els\":[\"0:120\"]},{\"tk\":[284,28,284,29],\"els\":[\"0:120\"]},{\"tk\":[287,5,287,7],\"els\":[\"0:120\"]},{\"tk\":[287,9,287,10],\"els\":[\"0:120\"]},{\"tk\":[287,10,287,14],\"els\":[\"0:124\"]},{\"tk\":[287,15,287,17],\"els\":[\"0:120\"]},{\"tk\":[287,18,287,19],\"els\":[\"0:120\"]},{\"tk\":[288,7,288,15],\"els\":[\"0:120\"]},{\"tk\":[288,17,288,47],\"els\":[\"0:120\"]},{\"tk\":[288,48,288,67],\"els\":[\"0:120\"]},{\"tk\":[288,67,288,68],\"els\":[\"0:120\"]},{\"tk\":[288,68,288,70],\"els\":[\"0:120\"]},{\"tk\":[291,5,291,7],\"els\":[\"0:120\"]},{\"tk\":[291,9,291,10],\"els\":[\"0:120\"]},{\"tk\":[291,10,291,14],\"els\":[\"0:124\"]},{\"tk\":[291,15,291,17],\"els\":[\"0:120\"]},{\"tk\":[291,18,291,19],\"els\":[\"0:120\"]},{\"tk\":[292,7,292,26],\"els\":[\"0:120\"]},{\"tk\":[292,28,292,58],\"els\":[\"0:120\"]},{\"tk\":[292,59,292,78],\"els\":[\"0:120\"]},{\"tk\":[292,78,292,79],\"els\":[\"0:120\"]},{\"tk\":[292,79,292,81],\"els\":[\"0:120\"]},{\"tk\":[293,7,293,9],\"els\":[\"0:120\"]},{\"tk\":[293,11,293,12],\"els\":[\"0:120\"]},{\"tk\":[293,12,293,16],\"els\":[\"0:124\"]},{\"tk\":[293,17,293,19],\"els\":[\"0:120\"]},{\"tk\":[293,20,293,21],\"els\":[\"0:120\"]},{\"tk\":[294,9,294,26],\"els\":[\"0:120\"]},{\"tk\":[294,26,294,27],\"els\":[\"0:120\"]},{\"tk\":[294,27,294,56],\"els\":[\"0:120\"]},{\"tk\":[294,56,294,57],\"els\":[\"0:120\"]},{\"tk\":[294,58,294,62],\"els\":[\"0:124\",\"0:120\"]},{\"tk\":[294,62,294,63],\"els\":[\"0:120\"]},{\"tk\":[295,9,295,28],\"els\":[\"0:120\"]},{\"tk\":[295,28,295,29],\"els\":[\"0:120\"]},{\"tk\":[295,29,295,58],\"els\":[\"0:120\"]},{\"tk\":[295,58,295,59],\"els\":[\"0:120\"]},{\"tk\":[295,60,295,61],\"els\":[\"0:120\"]},{\"tk\":[295,61,295,62],\"els\":[\"0:120\"]},{\"tk\":[302,5,302,8],\"els\":[\"0:95\",\"0:97\",\"0:94\"]},{\"tk\":[302,18,302,19],\"els\":[\"0:95\"]},{\"tk\":[302,22,302,23],\"els\":[\"0:95\",\"0:97\",\"0:94\"]},{\"tk\":[302,25,302,26],\"els\":[\"0:95\"]},{\"tk\":[302,29,302,31],\"els\":[\"0:95\",\"0:97\",\"0:94\"]},{\"tk\":[302,33,302,34],\"els\":[\"0:95\"]},{\"tk\":[302,34,302,36],\"els\":[\"0:95\",\"0:97\",\"0:94\"]},{\"tk\":[306,7,306,36],\"els\":[\"0:95\"]},{\"tk\":[306,37,306,40],\"els\":[\"0:95\"]},{\"tk\":[306,40,306,41],\"els\":[\"0:95\"]},{\"tk\":[306,41,306,42],\"els\":[\"0:95\"]},{\"tk\":[306,44,306,45],\"els\":[\"0:95\",\"0:97\",\"0:94\"]},{\"tk\":[307,9,307,38],\"els\":[\"0:97\"]},{\"tk\":[307,39,307,46],\"els\":[\"0:97\"]},{\"tk\":[313,5,313,35],\"els\":[\"0:49\"]},{\"tk\":[313,36,313,39],\"els\":[\"0:49\"]},{\"tk\":[313,40,313,62],\"els\":[\"0:49\"]},{\"tk\":[313,63,313,64],\"els\":[\"0:49\"]},{\"tk\":[313,65,313,69],\"els\":[\"0:49\"]},{\"tk\":[316,5,316,35],\"els\":[\"0:49\"]},{\"tk\":[316,36,316,39],\"els\":[\"0:49\"]},{\"tk\":[316,40,316,53],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:891-905,#15\",\"0:49\"]},{\"tk\":[316,54,316,55],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:891-905,#15\",\"0:49\"]},{\"tk\":[316,56,316,57],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:891-905,#15\",\"0:49\"]},{\"tk\":[319,5,319,35],\"els\":[\"0:49\"]},{\"tk\":[319,36,319,39],\"els\":[\"0:49\"]},{\"tk\":[319,40,319,62],\"els\":[\"0:49\"]},{\"tk\":[319,63,319,64],\"els\":[\"0:49\"]},{\"tk\":[319,65,319,70],\"els\":[\"0:49\"]},{\"tk\":[320,5,320,35],\"els\":[\"0:49\"]},{\"tk\":[320,36,320,39],\"els\":[\"0:49\"]},{\"tk\":[320,40,320,53],\"els\":[\"0:49\"]},{\"tk\":[320,54,320,55],\"els\":[\"0:49\"]},{\"tk\":[321,7,321,36],\"els\":[\"0:49\"]},{\"tk\":[321,37,321,68],\"els\":[\"0:49\"]},{\"tk\":[322,5,322,35],\"els\":[\"0:49\"]},{\"tk\":[322,36,322,39],\"els\":[\"0:49\"]},{\"tk\":[322,40,322,55],\"els\":[\"0:49\"]},{\"tk\":[322,56,322,57],\"els\":[\"0:49\"]},{\"tk\":[322,58,322,63],\"els\":[\"0:49\"]},{\"tk\":[323,5,323,35],\"els\":[\"0:49\"]},{\"tk\":[323,36,323,39],\"els\":[\"0:49\"]},{\"tk\":[323,40,323,53],\"els\":[\"0:49\"]},{\"tk\":[323,54,323,55],\"els\":[\"0:49\"]},{\"tk\":[323,56,323,57],\"els\":[\"0:49\"]},{\"tk\":[327,5,327,26],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:1431-1485,#92\",\"0:49\"]},{\"tk\":[327,27,327,57],\"els\":[\"0:49\"]},{\"tk\":[327,58,327,61],\"els\":[\"0:49\"]},{\"tk\":[328,5,328,35],\"els\":[\"0:49\"]},{\"tk\":[328,36,328,39],\"els\":[\"0:49\"]},{\"tk\":[328,40,328,55],\"els\":[\"0:49\"]},{\"tk\":[328,56,328,57],\"els\":[\"0:49\"]},{\"tk\":[328,58,328,62],\"els\":[\"0:49\"]},{\"tk\":[338,3,338,5],\"els\":[\"0:49\"]},{\"tk\":[338,7,338,8],\"els\":[\"0:49\"]},{\"tk\":[338,8,338,38],\"els\":[\"0:49\"]},{\"tk\":[338,39,338,42],\"els\":[\"0:49\"]},{\"tk\":[339,5,339,35],\"els\":[\"0:49\"]},{\"tk\":[339,36,339,39],\"els\":[\"0:49\"]},{\"tk\":[339,40,339,62],\"els\":[\"0:49\"]},{\"tk\":[339,63,339,64],\"els\":[\"0:49\"]},{\"tk\":[339,65,339,69],\"els\":[\"0:49\"]},{\"tk\":[340,5,340,7],\"els\":[\"0:49\"]},{\"tk\":[340,10,340,40],\"els\":[\"0:49\"]},{\"tk\":[340,41,340,44],\"els\":[\"0:49\"]},{\"tk\":[340,59,340,61],\"els\":[\"0:49\"]},{\"tk\":[340,62,340,63],\"els\":[\"0:49\"]},{\"tk\":[340,65,340,67],\"els\":[\"0:49\"]},{\"tk\":[341,9,341,39],\"els\":[\"0:49\"]},{\"tk\":[341,40,341,43],\"els\":[\"0:49\"]},{\"tk\":[343,7,343,27],\"els\":[\"0:\\\\Users\\\\SPOT\\\\Documents\\\\GitHub\\\\AlexCrain-SPOT\\\\Custom_Library\\\\PhaseSpase_Cameras\\\\PHASESPACE\\\\PhaseSpace_ALL.m:3143-3178,#122\",\"0:49\"]},{\"tk\":[350,3,350,7],\"els\":[\"0:124\"]},{\"tk\":[350,8,350,9],\"els\":[\"0:124\"]},{\"tk\":[350,10,350,24],\"els\":[\"0:124\"]},{\"tk\":[350,26,350,56],\"els\":[\"0:124\"]},{\"tk\":[350,57,350,76],\"els\":[\"0:124\"]},{\"tk\":[350,76,350,77],\"els\":[\"0:124\"]},{\"tk\":[350,77,350,79],\"els\":[\"0:124\"]},{\"tk\":[351,3,351,15],\"els\":[\"0:124\"]},{\"tk\":[351,17,351,47],\"els\":[\"0:124\"]},{\"tk\":[351,48,351,67],\"els\":[\"0:124\"]},{\"tk\":[351,67,351,68],\"els\":[\"0:124\"]},{\"tk\":[351,68,351,70],\"els\":[\"0:124\"]},{\"tk\":[352,3,352,5],\"els\":[\"0:124\"]},{\"tk\":[352,7,352,8],\"els\":[\"0:124\"]},{\"tk\":[352,8,352,12],\"els\":[\"0:124\"]},{\"tk\":[352,13,352,15],\"els\":[\"0:124\"]},{\"tk\":[352,16,352,17],\"els\":[\"0:124\"]},{\"tk\":[353,5,353,22],\"els\":[\"0:124\"]},{\"tk\":[353,22,353,23],\"els\":[\"0:124\"]},{\"tk\":[353,23,353,52],\"els\":[\"0:124\"]},{\"tk\":[353,52,353,53],\"els\":[\"0:124\"]},{\"tk\":[353,54,353,58],\"els\":[\"0:124\"]},{\"tk\":[353,58,353,59],\"els\":[\"0:124\"]},{\"tk\":[354,5,354,24],\"els\":[\"0:124\"]},{\"tk\":[354,24,354,25],\"els\":[\"0:124\"]},{\"tk\":[354,25,354,54],\"els\":[\"0:124\"]},{\"tk\":[354,54,354,55],\"els\":[\"0:124\"]},{\"tk\":[354,56,354,57],\"els\":[\"0:124\"]},{\"tk\":[354,57,354,58],\"els\":[\"0:124\"]},{\"tk\":[357,3,357,13],\"els\":[\"0:124\"]},{\"tk\":[357,15,357,45],\"els\":[\"0:124\"]},{\"tk\":[357,46,357,65],\"els\":[\"0:124\"]},{\"tk\":[357,65,357,66],\"els\":[\"0:124\"]},{\"tk\":[357,66,357,68],\"els\":[\"0:124\"]},{\"tk\":[357,71,357,72],\"els\":[\"0:124\"]},{\"tk\":[358,3,358,22],\"els\":[\"0:124\"]},{\"tk\":[358,24,358,54],\"els\":[\"0:124\"]},{\"tk\":[358,55,358,74],\"els\":[\"0:124\"]},{\"tk\":[358,74,358,75],\"els\":[\"0:124\"]},{\"tk\":[358,75,358,77],\"els\":[\"0:124\"]},{\"tk\":[363,3,363,7],\"els\":[\"0:124\"]},{\"tk\":[363,8,363,9],\"els\":[\"0:125\"]},{\"tk\":[363,10,363,24],\"els\":[\"0:125\"]},{\"tk\":[363,26,363,56],\"els\":[\"0:125\"]},{\"tk\":[363,57,363,76],\"els\":[\"0:125\"]},{\"tk\":[363,76,363,77],\"els\":[\"0:125\"]},{\"tk\":[363,77,363,79],\"els\":[\"0:125\"]},{\"tk\":[364,3,364,15],\"els\":[\"0:125\"]},{\"tk\":[364,17,364,47],\"els\":[\"0:125\"]},{\"tk\":[364,48,364,67],\"els\":[\"0:125\"]},{\"tk\":[364,67,364,68],\"els\":[\"0:125\"]},{\"tk\":[364,68,364,70],\"els\":[\"0:125\"]},{\"tk\":[365,3,365,5],\"els\":[\"0:125\"]},{\"tk\":[365,7,365,8],\"els\":[\"0:125\"]},{\"tk\":[365,8,365,12],\"els\":[\"0:124\"]},{\"tk\":[365,13,365,15],\"els\":[\"0:125\"]},{\"tk\":[365,16,365,17],\"els\":[\"0:125\"]},{\"tk\":[366,5,366,22],\"els\":[\"0:125\"]},{\"tk\":[366,22,366,23],\"els\":[\"0:125\"]},{\"tk\":[366,23,366,52],\"els\":[\"0:125\"]},{\"tk\":[366,52,366,53],\"els\":[\"0:125\"]},{\"tk\":[366,54,366,58],\"els\":[\"0:124\",\"0:125\"]},{\"tk\":[366,58,366,59],\"els\":[\"0:125\"]},{\"tk\":[367,5,367,24],\"els\":[\"0:125\"]},{\"tk\":[367,24,367,25],\"els\":[\"0:125\"]},{\"tk\":[367,25,367,54],\"els\":[\"0:125\"]},{\"tk\":[367,54,367,55],\"els\":[\"0:125\"]},{\"tk\":[367,56,367,57],\"els\":[\"0:125\"]},{\"tk\":[367,57,367,58],\"els\":[\"0:125\"]},{\"tk\":[370,3,370,13],\"els\":[\"0:125\"]},{\"tk\":[370,15,370,45],\"els\":[\"0:125\"]},{\"tk\":[370,46,370,65],\"els\":[\"0:125\"]},{\"tk\":[370,65,370,66],\"els\":[\"0:125\"]},{\"tk\":[370,66,370,68],\"els\":[\"0:125\"]},{\"tk\":[370,71,370,72],\"els\":[\"0:125\"]},{\"tk\":[371,3,371,22],\"els\":[\"0:125\"]},{\"tk\":[371,24,371,54],\"els\":[\"0:125\"]},{\"tk\":[371,55,371,74],\"els\":[\"0:125\"]},{\"tk\":[371,74,371,75],\"els\":[\"0:125\"]},{\"tk\":[371,75,371,77],\"els\":[\"0:125\"]},{\"tk\":[376,3,376,7],\"els\":[\"0:124\"]},{\"tk\":[376,8,376,9],\"els\":[\"0:123\"]},{\"tk\":[376,10,376,24],\"els\":[\"0:123\"]},{\"tk\":[376,26,376,56],\"els\":[\"0:123\"]},{\"tk\":[376,57,376,76],\"els\":[\"0:123\"]},{\"tk\":[376,76,376,77],\"els\":[\"0:123\"]},{\"tk\":[376,77,376,79],\"els\":[\"0:123\"]},{\"tk\":[377,3,377,15],\"els\":[\"0:123\"]},{\"tk\":[377,17,377,47],\"els\":[\"0:123\"]},{\"tk\":[377,48,377,67],\"els\":[\"0:123\"]},{\"tk\":[377,67,377,68],\"els\":[\"0:123\"]},{\"tk\":[377,68,377,70],\"els\":[\"0:123\"]},{\"tk\":[378,3,378,5],\"els\":[\"0:123\"]},{\"tk\":[378,7,378,8],\"els\":[\"0:123\"]},{\"tk\":[378,8,378,12],\"els\":[\"0:124\"]},{\"tk\":[378,13,378,15],\"els\":[\"0:123\"]},{\"tk\":[378,16,378,17],\"els\":[\"0:123\"]},{\"tk\":[379,5,379,22],\"els\":[\"0:123\"]},{\"tk\":[379,22,379,23],\"els\":[\"0:123\"]},{\"tk\":[379,23,379,52],\"els\":[\"0:123\"]},{\"tk\":[379,52,379,53],\"els\":[\"0:123\"]},{\"tk\":[379,54,379,58],\"els\":[\"0:124\",\"0:123\"]},{\"tk\":[379,58,379,59],\"els\":[\"0:123\"]},{\"tk\":[380,5,380,24],\"els\":[\"0:123\"]},{\"tk\":[380,24,380,25],\"els\":[\"0:123\"]},{\"tk\":[380,25,380,54],\"els\":[\"0:123\"]},{\"tk\":[380,54,380,55],\"els\":[\"0:123\"]},{\"tk\":[380,56,380,57],\"els\":[\"0:123\"]},{\"tk\":[380,57,380,58],\"els\":[\"0:123\"]},{\"tk\":[383,3,383,13],\"els\":[\"0:123\"]},{\"tk\":[383,15,383,45],\"els\":[\"0:123\"]},{\"tk\":[383,46,383,65],\"els\":[\"0:123\"]},{\"tk\":[383,65,383,66],\"els\":[\"0:123\"]},{\"tk\":[383,66,383,68],\"els\":[\"0:123\"]},{\"tk\":[383,71,383,72],\"els\":[\"0:123\"]},{\"tk\":[384,3,384,22],\"els\":[\"0:123\"]},{\"tk\":[384,24,384,54],\"els\":[\"0:123\"]},{\"tk\":[384,55,384,74],\"els\":[\"0:123\"]},{\"tk\":[384,74,384,75],\"els\":[\"0:123\"]},{\"tk\":[384,75,384,77],\"els\":[\"0:123\"]},{\"tk\":[389,3,389,7],\"els\":[\"0:124\"]},{\"tk\":[389,8,389,9],\"els\":[\"0:120\"]},{\"tk\":[389,10,389,24],\"els\":[\"0:120\"]},{\"tk\":[389,26,389,56],\"els\":[\"0:120\"]},{\"tk\":[389,57,389,76],\"els\":[\"0:120\"]},{\"tk\":[389,76,389,77],\"els\":[\"0:120\"]},{\"tk\":[389,77,389,79],\"els\":[\"0:120\"]},{\"tk\":[390,3,390,15],\"els\":[\"0:120\"]},{\"tk\":[390,17,390,47],\"els\":[\"0:120\"]},{\"tk\":[390,48,390,67],\"els\":[\"0:120\"]},{\"tk\":[390,67,390,68],\"els\":[\"0:120\"]},{\"tk\":[390,68,390,70],\"els\":[\"0:120\"]},{\"tk\":[391,3,391,5],\"els\":[\"0:120\"]},{\"tk\":[391,7,391,8],\"els\":[\"0:120\"]},{\"tk\":[391,8,391,12],\"els\":[\"0:124\"]},{\"tk\":[391,13,391,15],\"els\":[\"0:120\"]},{\"tk\":[391,16,391,17],\"els\":[\"0:120\"]},{\"tk\":[392,5,392,22],\"els\":[\"0:120\"]},{\"tk\":[392,22,392,23],\"els\":[\"0:120\"]},{\"tk\":[392,23,392,52],\"els\":[\"0:120\"]},{\"tk\":[392,52,392,53],\"els\":[\"0:120\"]},{\"tk\":[392,54,392,58],\"els\":[\"0:124\",\"0:120\"]},{\"tk\":[392,58,392,59],\"els\":[\"0:120\"]},{\"tk\":[393,5,393,24],\"els\":[\"0:120\"]},{\"tk\":[393,24,393,25],\"els\":[\"0:120\"]},{\"tk\":[393,25,393,54],\"els\":[\"0:120\"]},{\"tk\":[393,54,393,55],\"els\":[\"0:120\"]},{\"tk\":[393,56,393,57],\"els\":[\"0:120\"]},{\"tk\":[393,57,393,58],\"els\":[\"0:120\"]},{\"tk\":[396,3,396,13],\"els\":[\"0:120\"]},{\"tk\":[396,15,396,45],\"els\":[\"0:120\"]},{\"tk\":[396,46,396,65],\"els\":[\"0:120\"]},{\"tk\":[396,65,396,66],\"els\":[\"0:120\"]},{\"tk\":[396,66,396,68],\"els\":[\"0:120\"]},{\"tk\":[396,71,396,72],\"els\":[\"0:120\"]},{\"tk\":[397,3,397,22],\"els\":[\"0:120\"]},{\"tk\":[397,24,397,54],\"els\":[\"0:120\"]},{\"tk\":[397,55,397,74],\"els\":[\"0:120\"]},{\"tk\":[397,74,397,75],\"els\":[\"0:120\"]},{\"tk\":[397,75,397,77],\"els\":[\"0:120\"]}]}}}","blocks":[{"RTWName":"<S1>/u","SIDString":"CollectPhaseSpaceDataJetson:83:1"},{"RTWName":"<S1>/Compare","SIDString":"CollectPhaseSpaceDataJetson:83:2"},{"RTWName":"<S1>/Constant","SIDString":"CollectPhaseSpaceDataJetson:83:3"},{"RTWName":"<S1>/y","SIDString":"CollectPhaseSpaceDataJetson:83:5"},{"RTWName":"<Root>/Data Type Conversion","SIDString":"CollectPhaseSpaceDataJetson:122"},{"RTWName":"<Root>/Demux1","SIDString":"CollectPhaseSpaceDataJetson:93"},{"RTWName":"<S2>/In1","SIDString":"CollectPhaseSpaceDataJetson:95"},{"RTWName":"<S2>/Enable","SIDString":"CollectPhaseSpaceDataJetson:96"},{"RTWName":"<S2>/Out1","SIDString":"CollectPhaseSpaceDataJetson:97"},{"RTWName":"<Root>/Mux1","SIDString":"CollectPhaseSpaceDataJetson:102"},{"RTWName":"<Root>/Stream PhaseSpace to Platform","SIDString":"CollectPhaseSpaceDataJetson:49"},{"RTWName":"<Root>/UDP Send1","SIDString":"CollectPhaseSpaceDataJetson:124"},{"RTWName":"<Root>/UDP Send2","SIDString":"CollectPhaseSpaceDataJetson:125"},{"RTWName":"<Root>/UDP Send3","SIDString":"CollectPhaseSpaceDataJetson:123"},{"RTWName":"<Root>/UDP Send4","SIDString":"CollectPhaseSpaceDataJetson:120"},{"RTWName":"<Root>/Compare\nTo Zero1","SIDString":"CollectPhaseSpaceDataJetson:83"},{"RTWName":"<Root>/Enabled\nSubsystem1","SIDString":"CollectPhaseSpaceDataJetson:94"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};